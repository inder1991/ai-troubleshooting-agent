import { monitor, monitorError } from '../tools/monitor';
import { isExperimentalFeatureEnabled, ExperimentalFeature } from '../tools/experimentalFeatures';
import { Observable } from '../tools/observable';
import { ONE_KIBI_BYTE } from '../tools/utils/byteUtils';
import { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy';
/**
 * beacon payload max queue size implementation is 64kb
 * ensure that we leave room for logs, rum and potential other users
 */
export const RECOMMENDED_REQUEST_BYTES_LIMIT = 16 * ONE_KIBI_BYTE;
export function createHttpRequest(endpointBuilders, reportError, bytesLimit = RECOMMENDED_REQUEST_BYTES_LIMIT) {
    const observable = new Observable();
    const retryState = newRetryState();
    return {
        observable,
        send: (payload) => {
            for (const endpointBuilder of endpointBuilders) {
                sendWithRetryStrategy(payload, retryState, (payload, onResponse) => {
                    if (isExperimentalFeatureEnabled(ExperimentalFeature.AVOID_FETCH_KEEPALIVE)) {
                        fetchStrategy(endpointBuilder, payload, onResponse);
                    }
                    else {
                        fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse);
                    }
                }, endpointBuilder.trackType, reportError, observable);
            }
        },
        /**
         * Since fetch keepalive behaves like regular fetch on Firefox,
         * keep using sendBeaconStrategy on exit
         */
        sendOnExit: (payload) => {
            for (const endpointBuilder of endpointBuilders) {
                sendBeaconStrategy(endpointBuilder, bytesLimit, payload);
            }
        },
    };
}
function sendBeaconStrategy(endpointBuilder, bytesLimit, payload) {
    const canUseBeacon = !!navigator.sendBeacon && payload.bytesCount < bytesLimit;
    if (canUseBeacon) {
        try {
            const beaconUrl = endpointBuilder.build('beacon', payload);
            const isQueued = navigator.sendBeacon(beaconUrl, payload.data);
            if (isQueued) {
                return;
            }
        }
        catch (e) {
            reportBeaconError(e);
        }
    }
    fetchStrategy(endpointBuilder, payload);
}
let hasReportedBeaconError = false;
function reportBeaconError(e) {
    if (!hasReportedBeaconError) {
        hasReportedBeaconError = true;
        monitorError(e);
    }
}
export function fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse) {
    const canUseKeepAlive = isKeepAliveSupported() && payload.bytesCount < bytesLimit;
    if (canUseKeepAlive) {
        const fetchUrl = endpointBuilder.build('fetch-keepalive', payload);
        fetch(fetchUrl, { method: 'POST', body: payload.data, keepalive: true, mode: 'cors' })
            .then(monitor((response) => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: response.status, type: response.type })))
            .catch(monitor(() => fetchStrategy(endpointBuilder, payload, onResponse)));
    }
    else {
        fetchStrategy(endpointBuilder, payload, onResponse);
    }
}
export function fetchStrategy(endpointBuilder, payload, onResponse) {
    const fetchUrl = endpointBuilder.build('fetch', payload);
    fetch(fetchUrl, { method: 'POST', body: payload.data, mode: 'cors' })
        .then(monitor((response) => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: response.status, type: response.type })))
        .catch(monitor(() => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: 0 })));
}
function isKeepAliveSupported() {
    // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors
    try {
        return window.Request && 'keepalive' in new Request('http://a');
    }
    catch (_a) {
        return false;
    }
}
//# sourceMappingURL=httpRequest.js.map