"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectCookieStrategy = selectCookieStrategy;
exports.initCookieStrategy = initCookieStrategy;
exports.retrieveSessionCookie = retrieveSessionCookie;
exports.buildCookieOptions = buildCookieOptions;
const objectUtils_1 = require("../../../tools/utils/objectUtils");
const browserDetection_1 = require("../../../tools/utils/browserDetection");
const cookie_1 = require("../../../browser/cookie");
const oldCookiesMigration_1 = require("../oldCookiesMigration");
const sessionConstants_1 = require("../sessionConstants");
const sessionState_1 = require("../sessionState");
const sessionStoreStrategy_1 = require("./sessionStoreStrategy");
const SESSION_COOKIE_VERSION = 0;
function selectCookieStrategy(initConfiguration) {
    const cookieOptions = buildCookieOptions(initConfiguration);
    return cookieOptions && (0, cookie_1.areCookiesAuthorized)(cookieOptions)
        ? { type: sessionConstants_1.SessionPersistence.COOKIE, cookieOptions }
        : undefined;
}
function initCookieStrategy(configuration, cookieOptions) {
    const cookieStore = {
        /**
         * Lock strategy allows mitigating issues due to concurrent access to cookie.
         * This issue concerns only chromium browsers and enabling this on firefox increases cookie write failures.
         */
        isLockEnabled: (0, browserDetection_1.isChromium)(),
        persistSession: (sessionState) => storeSessionCookie(cookieOptions, configuration, sessionState, sessionConstants_1.SESSION_EXPIRATION_DELAY),
        retrieveSession: () => retrieveSessionCookie(cookieOptions, configuration),
        expireSession: (sessionState) => storeSessionCookie(cookieOptions, configuration, (0, sessionState_1.getExpiredSessionState)(sessionState, configuration), sessionConstants_1.SESSION_TIME_OUT_DELAY),
    };
    (0, oldCookiesMigration_1.tryOldCookiesMigration)(cookieStore);
    return cookieStore;
}
function storeSessionCookie(options, configuration, sessionState, defaultTimeout) {
    let sessionStateString = (0, sessionState_1.toSessionString)(sessionState);
    if (configuration.betaEncodeCookieOptions) {
        sessionStateString = (0, sessionState_1.toSessionString)({
            ...sessionState,
            // deleting a cookie is writing a new cookie with an empty value
            // we don't want to store the cookie options in this case otherwise the cookie will not be deleted
            ...(!(0, objectUtils_1.isEmptyObject)(sessionState) ? { c: encodeCookieOptions(options) } : {}),
        });
    }
    (0, cookie_1.setCookie)(sessionStoreStrategy_1.SESSION_STORE_KEY, sessionStateString, configuration.trackAnonymousUser ? sessionConstants_1.SESSION_COOKIE_EXPIRATION_DELAY : defaultTimeout, options);
}
/**
 * Retrieve the session state from the cookie that was set with the same cookie options
 * If there is no match, return the first cookie, because that's how `getCookie()` works
 */
function retrieveSessionCookie(cookieOptions, configuration) {
    if (configuration.betaEncodeCookieOptions) {
        return retrieveSessionCookieFromEncodedCookie(cookieOptions);
    }
    const sessionString = (0, cookie_1.getCookie)(sessionStoreStrategy_1.SESSION_STORE_KEY);
    const sessionState = (0, sessionState_1.toSessionState)(sessionString);
    return sessionState;
}
function buildCookieOptions(initConfiguration) {
    const cookieOptions = {};
    cookieOptions.secure =
        !!initConfiguration.useSecureSessionCookie || !!initConfiguration.usePartitionedCrossSiteSessionCookie;
    cookieOptions.crossSite = !!initConfiguration.usePartitionedCrossSiteSessionCookie;
    cookieOptions.partitioned = !!initConfiguration.usePartitionedCrossSiteSessionCookie;
    if (initConfiguration.trackSessionAcrossSubdomains) {
        const currentSite = (0, cookie_1.getCurrentSite)();
        if (!currentSite) {
            return;
        }
        cookieOptions.domain = currentSite;
    }
    return cookieOptions;
}
function encodeCookieOptions(cookieOptions) {
    const domainCount = cookieOptions.domain ? cookieOptions.domain.split('.').length - 1 : 0;
    /* eslint-disable no-bitwise */
    let byte = 0;
    byte |= SESSION_COOKIE_VERSION << 5; // Store version in upper 3 bits
    byte |= domainCount << 1; // Store domain count in next 4 bits
    byte |= cookieOptions.crossSite ? 1 : 0; // Store useCrossSiteScripting in next bit
    /* eslint-enable no-bitwise */
    return byte.toString(16); // Convert to hex string
}
/**
 * Retrieve the session state from the cookie that was set with the same cookie options.
 * If there is no match, fallback to the first cookie, (because that's how `getCookie()` works)
 * and this allows to keep the current session id when we release this feature.
 */
function retrieveSessionCookieFromEncodedCookie(cookieOptions) {
    const cookies = (0, cookie_1.getCookies)(sessionStoreStrategy_1.SESSION_STORE_KEY);
    const opts = encodeCookieOptions(cookieOptions);
    let sessionState;
    // reverse the cookies so that if there is no match, the cookie returned is the first one
    for (const cookie of cookies.reverse()) {
        sessionState = (0, sessionState_1.toSessionState)(cookie);
        if (sessionState.c === opts) {
            break;
        }
    }
    // remove the cookie options from the session state as this is not part of the session state
    sessionState === null || sessionState === void 0 ? true : delete sessionState.c;
    return sessionState !== null && sessionState !== void 0 ? sessionState : {};
}
//# sourceMappingURL=sessionInCookie.js.map