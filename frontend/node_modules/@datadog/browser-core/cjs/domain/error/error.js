"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NO_ERROR_STACK_PRESENT_MESSAGE = void 0;
exports.computeRawError = computeRawError;
exports.tryToGetFingerprint = tryToGetFingerprint;
exports.tryToGetErrorContext = tryToGetErrorContext;
exports.getFileFromStackTraceString = getFileFromStackTraceString;
exports.isError = isError;
exports.flattenErrorCauses = flattenErrorCauses;
const sanitize_1 = require("../../tools/serialisation/sanitize");
const jsonStringify_1 = require("../../tools/serialisation/jsonStringify");
const computeStackTrace_1 = require("../../tools/stackTrace/computeStackTrace");
const handlingStack_1 = require("../../tools/stackTrace/handlingStack");
const typeUtils_1 = require("../../tools/utils/typeUtils");
exports.NO_ERROR_STACK_PRESENT_MESSAGE = 'No stack, consider using an instance of Error';
function computeErrorBase({ originalError, stackTrace, source, useFallbackStack = true, nonErrorPrefix, }) {
    const isErrorInstance = isError(originalError);
    if (!stackTrace && isErrorInstance) {
        stackTrace = (0, computeStackTrace_1.computeStackTrace)(originalError);
    }
    return {
        source,
        type: stackTrace ? stackTrace.name : undefined,
        message: computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError),
        stack: stackTrace ? (0, handlingStack_1.toStackTraceString)(stackTrace) : useFallbackStack ? exports.NO_ERROR_STACK_PRESENT_MESSAGE : undefined,
    };
}
function computeRawError({ stackTrace, originalError, handlingStack, componentStack, startClocks, nonErrorPrefix, useFallbackStack = true, source, handling, }) {
    const errorBase = computeErrorBase({ originalError, stackTrace, source, useFallbackStack, nonErrorPrefix });
    return {
        startClocks,
        handling,
        handlingStack,
        componentStack,
        originalError,
        ...errorBase,
        causes: isError(originalError) ? flattenErrorCauses(originalError, source) : undefined,
        fingerprint: tryToGetFingerprint(originalError),
        context: tryToGetErrorContext(originalError),
    };
}
function computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError) {
    // Favor stackTrace message only if tracekit has really been able to extract something meaningful (message + name)
    // TODO rework tracekit integration to avoid scattering error building logic
    return (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.message) && (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name)
        ? stackTrace.message
        : !isErrorInstance
            ? nonErrorPrefix
                ? `${nonErrorPrefix} ${(0, jsonStringify_1.jsonStringify)((0, sanitize_1.sanitize)(originalError))}`
                : (0, jsonStringify_1.jsonStringify)((0, sanitize_1.sanitize)(originalError))
            : 'Empty message';
}
function tryToGetFingerprint(originalError) {
    return isError(originalError) && 'dd_fingerprint' in originalError ? String(originalError.dd_fingerprint) : undefined;
}
function tryToGetErrorContext(originalError) {
    if ((0, typeUtils_1.isIndexableObject)(originalError)) {
        return originalError.dd_context;
    }
}
function getFileFromStackTraceString(stack) {
    var _a;
    return (_a = /@ (.+)/.exec(stack)) === null || _a === void 0 ? void 0 : _a[1];
}
function isError(error) {
    return error instanceof Error || Object.prototype.toString.call(error) === '[object Error]';
}
function flattenErrorCauses(error, parentSource) {
    const causes = [];
    let currentCause = error.cause;
    while (currentCause !== undefined && currentCause !== null && causes.length < 10) {
        const causeBase = computeErrorBase({
            originalError: currentCause,
            source: parentSource,
            useFallbackStack: false,
        });
        causes.push(causeBase);
        currentCause = isError(currentCause) ? currentCause.cause : undefined;
    }
    return causes.length ? causes : undefined;
}
//# sourceMappingURL=error.js.map