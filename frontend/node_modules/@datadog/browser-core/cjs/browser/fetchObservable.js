"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initFetchObservable = initFetchObservable;
exports.resetFetchObservable = resetFetchObservable;
const instrumentMethod_1 = require("../tools/instrumentMethod");
const monitor_1 = require("../tools/monitor");
const observable_1 = require("../tools/observable");
const timeUtils_1 = require("../tools/utils/timeUtils");
const urlPolyfill_1 = require("../tools/utils/urlPolyfill");
const globalObject_1 = require("../tools/globalObject");
const readBytesFromStream_1 = require("../tools/readBytesFromStream");
const responseUtils_1 = require("../tools/utils/responseUtils");
let fetchObservable;
const responseBodyActionGetters = [];
function initFetchObservable({ responseBodyAction } = {}) {
    if (responseBodyAction) {
        responseBodyActionGetters.push(responseBodyAction);
    }
    if (!fetchObservable) {
        fetchObservable = createFetchObservable();
    }
    return fetchObservable;
}
function resetFetchObservable() {
    fetchObservable = undefined;
    responseBodyActionGetters.length = 0;
}
function createFetchObservable() {
    return new observable_1.Observable((observable) => {
        if (!globalObject_1.globalObject.fetch) {
            return;
        }
        const { stop } = (0, instrumentMethod_1.instrumentMethod)(globalObject_1.globalObject, 'fetch', (call) => beforeSend(call, observable), {
            computeHandlingStack: true,
        });
        return stop;
    });
}
function beforeSend({ parameters, onPostCall, handlingStack }, observable) {
    const [input, init] = parameters;
    let methodFromParams = init && init.method;
    if (methodFromParams === undefined && input instanceof Request) {
        methodFromParams = input.method;
    }
    const method = methodFromParams !== undefined ? String(methodFromParams).toUpperCase() : 'GET';
    const url = input instanceof Request ? input.url : (0, urlPolyfill_1.normalizeUrl)(String(input));
    const startClocks = (0, timeUtils_1.clocksNow)();
    const context = {
        state: 'start',
        init,
        input,
        method,
        startClocks,
        url,
        handlingStack,
    };
    observable.notify(context);
    // Those properties can be changed by observable subscribers
    parameters[0] = context.input;
    parameters[1] = context.init;
    onPostCall((responsePromise) => {
        afterSend(observable, responsePromise, context).catch(monitor_1.monitorError);
    });
}
async function afterSend(observable, responsePromise, startContext) {
    var _a, _b;
    const context = startContext;
    context.state = 'resolve';
    let response;
    try {
        response = await responsePromise;
    }
    catch (error) {
        context.status = 0;
        context.isAborted =
            ((_b = (_a = context.init) === null || _a === void 0 ? void 0 : _a.signal) === null || _b === void 0 ? void 0 : _b.aborted) || (error instanceof DOMException && error.code === DOMException.ABORT_ERR);
        context.error = error;
        observable.notify(context);
        return;
    }
    context.response = response;
    context.status = response.status;
    context.responseType = response.type;
    context.isAborted = false;
    const responseBodyCondition = responseBodyActionGetters.reduce((action, getter) => Math.max(action, getter(context)), 0 /* ResponseBodyAction.IGNORE */);
    if (responseBodyCondition !== 0 /* ResponseBodyAction.IGNORE */) {
        const clonedResponse = (0, responseUtils_1.tryToClone)(response);
        if (clonedResponse && clonedResponse.body) {
            try {
                const bytes = await (0, readBytesFromStream_1.readBytesFromStream)(clonedResponse.body, {
                    collectStreamBody: responseBodyCondition === 2 /* ResponseBodyAction.COLLECT */,
                });
                context.responseBody = bytes && new TextDecoder().decode(bytes);
            }
            catch (_c) {
                // Ignore errors when reading the response body (e.g., stream aborted, network errors)
                // This is not critical and should not be reported as an SDK error
            }
        }
    }
    observable.notify(context);
}
//# sourceMappingURL=fetchObservable.js.map