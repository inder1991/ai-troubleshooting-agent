"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MESSAGES_LIMIT = exports.FLUSH_DURATION_LIMIT = void 0;
exports.createFlushController = createFlushController;
const globalObject_1 = require("../tools/globalObject");
const observable_1 = require("../tools/observable");
const timer_1 = require("../tools/timer");
const timeUtils_1 = require("../tools/utils/timeUtils");
const httpRequest_1 = require("./httpRequest");
/**
 * flush automatically, aim to be lower than ALB connection timeout
 * to maximize connection reuse.
 */
exports.FLUSH_DURATION_LIMIT = (30 * timeUtils_1.ONE_SECOND);
/**
 * When using the SDK in a Worker Environment, we limit the batch size to 1 to ensure it can be sent
 * in a single event.
 */
exports.MESSAGES_LIMIT = globalObject_1.isWorkerEnvironment ? 1 : 50;
/**
 * Returns a "flush controller", responsible of notifying when flushing a pool of pending data needs
 * to happen. The implementation is designed to support both synchronous and asynchronous usages,
 * but relies on invariants described in each method documentation to keep a coherent state.
 */
function createFlushController({ pageMayExitObservable, sessionExpireObservable }) {
    const pageMayExitSubscription = pageMayExitObservable.subscribe((event) => flush(event.reason));
    const sessionExpireSubscription = sessionExpireObservable.subscribe(() => flush('session_expire'));
    const flushObservable = new observable_1.Observable(() => () => {
        pageMayExitSubscription.unsubscribe();
        sessionExpireSubscription.unsubscribe();
    });
    let currentBytesCount = 0;
    let currentMessagesCount = 0;
    function flush(flushReason) {
        if (currentMessagesCount === 0) {
            return;
        }
        const messagesCount = currentMessagesCount;
        const bytesCount = currentBytesCount;
        currentMessagesCount = 0;
        currentBytesCount = 0;
        cancelDurationLimitTimeout();
        flushObservable.notify({
            reason: flushReason,
            messagesCount,
            bytesCount,
        });
    }
    let durationLimitTimeoutId;
    function scheduleDurationLimitTimeout() {
        if (durationLimitTimeoutId === undefined) {
            durationLimitTimeoutId = (0, timer_1.setTimeout)(() => {
                flush('duration_limit');
            }, exports.FLUSH_DURATION_LIMIT);
        }
    }
    function cancelDurationLimitTimeout() {
        (0, timer_1.clearTimeout)(durationLimitTimeoutId);
        durationLimitTimeoutId = undefined;
    }
    return {
        flushObservable,
        get messagesCount() {
            return currentMessagesCount;
        },
        /**
         * Notifies that a message will be added to a pool of pending messages waiting to be flushed.
         *
         * This function needs to be called synchronously, right before adding the message, so no flush
         * event can happen after `notifyBeforeAddMessage` and before adding the message.
         *
         * @param estimatedMessageBytesCount - an estimation of the message bytes count once it is
         * actually added.
         */
        notifyBeforeAddMessage(estimatedMessageBytesCount) {
            if (currentBytesCount + estimatedMessageBytesCount >= httpRequest_1.RECOMMENDED_REQUEST_BYTES_LIMIT) {
                flush('bytes_limit');
            }
            // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no
            // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want
            // to notify when a flush is needed (for example on page exit).
            currentMessagesCount += 1;
            currentBytesCount += estimatedMessageBytesCount;
            scheduleDurationLimitTimeout();
        },
        /**
         * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.
         *
         * This function can be called asynchronously after the message was added, but in this case it
         * should not be called if a flush event occurred in between.
         *
         * @param messageBytesCountDiff - the difference between the estimated message bytes count and
         * its actual bytes count once added to the pool.
         */
        notifyAfterAddMessage(messageBytesCountDiff = 0) {
            currentBytesCount += messageBytesCountDiff;
            if (currentMessagesCount >= exports.MESSAGES_LIMIT) {
                flush('messages_limit');
            }
            else if (currentBytesCount >= httpRequest_1.RECOMMENDED_REQUEST_BYTES_LIMIT) {
                flush('bytes_limit');
            }
        },
        /**
         * Notifies that a message was removed from a pool of pending messages waiting to be flushed.
         *
         * This function needs to be called synchronously, right after removing the message, so no flush
         * event can happen after removing the message and before `notifyAfterRemoveMessage`.
         *
         * @param messageBytesCount - the message bytes count that was added to the pool. Should
         * correspond to the sum of bytes counts passed to `notifyBeforeAddMessage` and
         * `notifyAfterAddMessage`.
         */
        notifyAfterRemoveMessage(messageBytesCount) {
            currentBytesCount -= messageBytesCount;
            currentMessagesCount -= 1;
            if (currentMessagesCount === 0) {
                cancelDurationLimitTimeout();
            }
        },
    };
}
//# sourceMappingURL=flushController.js.map