"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RECOMMENDED_REQUEST_BYTES_LIMIT = void 0;
exports.createHttpRequest = createHttpRequest;
exports.fetchKeepAliveStrategy = fetchKeepAliveStrategy;
exports.fetchStrategy = fetchStrategy;
const monitor_1 = require("../tools/monitor");
const experimentalFeatures_1 = require("../tools/experimentalFeatures");
const observable_1 = require("../tools/observable");
const byteUtils_1 = require("../tools/utils/byteUtils");
const sendWithRetryStrategy_1 = require("./sendWithRetryStrategy");
/**
 * beacon payload max queue size implementation is 64kb
 * ensure that we leave room for logs, rum and potential other users
 */
exports.RECOMMENDED_REQUEST_BYTES_LIMIT = 16 * byteUtils_1.ONE_KIBI_BYTE;
function createHttpRequest(endpointBuilders, reportError, bytesLimit = exports.RECOMMENDED_REQUEST_BYTES_LIMIT) {
    const observable = new observable_1.Observable();
    const retryState = (0, sendWithRetryStrategy_1.newRetryState)();
    return {
        observable,
        send: (payload) => {
            for (const endpointBuilder of endpointBuilders) {
                (0, sendWithRetryStrategy_1.sendWithRetryStrategy)(payload, retryState, (payload, onResponse) => {
                    if ((0, experimentalFeatures_1.isExperimentalFeatureEnabled)(experimentalFeatures_1.ExperimentalFeature.AVOID_FETCH_KEEPALIVE)) {
                        fetchStrategy(endpointBuilder, payload, onResponse);
                    }
                    else {
                        fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse);
                    }
                }, endpointBuilder.trackType, reportError, observable);
            }
        },
        /**
         * Since fetch keepalive behaves like regular fetch on Firefox,
         * keep using sendBeaconStrategy on exit
         */
        sendOnExit: (payload) => {
            for (const endpointBuilder of endpointBuilders) {
                sendBeaconStrategy(endpointBuilder, bytesLimit, payload);
            }
        },
    };
}
function sendBeaconStrategy(endpointBuilder, bytesLimit, payload) {
    const canUseBeacon = !!navigator.sendBeacon && payload.bytesCount < bytesLimit;
    if (canUseBeacon) {
        try {
            const beaconUrl = endpointBuilder.build('beacon', payload);
            const isQueued = navigator.sendBeacon(beaconUrl, payload.data);
            if (isQueued) {
                return;
            }
        }
        catch (e) {
            reportBeaconError(e);
        }
    }
    fetchStrategy(endpointBuilder, payload);
}
let hasReportedBeaconError = false;
function reportBeaconError(e) {
    if (!hasReportedBeaconError) {
        hasReportedBeaconError = true;
        (0, monitor_1.monitorError)(e);
    }
}
function fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse) {
    const canUseKeepAlive = isKeepAliveSupported() && payload.bytesCount < bytesLimit;
    if (canUseKeepAlive) {
        const fetchUrl = endpointBuilder.build('fetch-keepalive', payload);
        fetch(fetchUrl, { method: 'POST', body: payload.data, keepalive: true, mode: 'cors' })
            .then((0, monitor_1.monitor)((response) => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: response.status, type: response.type })))
            .catch((0, monitor_1.monitor)(() => fetchStrategy(endpointBuilder, payload, onResponse)));
    }
    else {
        fetchStrategy(endpointBuilder, payload, onResponse);
    }
}
function fetchStrategy(endpointBuilder, payload, onResponse) {
    const fetchUrl = endpointBuilder.build('fetch', payload);
    fetch(fetchUrl, { method: 'POST', body: payload.data, mode: 'cors' })
        .then((0, monitor_1.monitor)((response) => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: response.status, type: response.type })))
        .catch((0, monitor_1.monitor)(() => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: 0 })));
}
function isKeepAliveSupported() {
    // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors
    try {
        return window.Request && 'keepalive' in new Request('http://a');
    }
    catch (_a) {
        return false;
    }
}
//# sourceMappingURL=httpRequest.js.map