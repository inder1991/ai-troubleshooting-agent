"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_RUM_PROFILER_CONFIGURATION = void 0;
exports.createRumProfiler = createRumProfiler;
const browser_core_1 = require("@datadog/browser-core");
const browser_rum_core_1 = require("@datadog/browser-rum-core");
const getNumberOfSamples_1 = require("./utils/getNumberOfSamples");
const getCustomOrDefaultViewName_1 = require("./utils/getCustomOrDefaultViewName");
const assembly_1 = require("./transport/assembly");
exports.DEFAULT_RUM_PROFILER_CONFIGURATION = {
    sampleIntervalMs: 10, // Sample stack trace every 10ms
    collectIntervalMs: 60000, // Collect data every minute
    minProfileDurationMs: 5000, // Require at least 5 seconds of profile data to reduce noise and cost
    minNumberOfSamples: 50, // Require at least 50 samples (~500 ms) to report a profile to reduce noise and cost
};
function createRumProfiler(configuration, lifeCycle, session, profilingContextManager, longTaskContexts, createEncoder, viewHistory, profilerConfiguration = exports.DEFAULT_RUM_PROFILER_CONFIGURATION) {
    const transport = (0, browser_rum_core_1.createFormDataTransport)(configuration, lifeCycle, createEncoder, 6 /* DeflateEncoderStreamId.PROFILING */);
    let lastViewEntry;
    // Global clean-up tasks for listeners that are not specific to a profiler instance (eg. visibility change, before unload)
    const globalCleanupTasks = [];
    let instance = { state: 'stopped', stateReason: 'initializing' };
    // Stops the profiler when session expires
    lifeCycle.subscribe(9 /* LifeCycleEventType.SESSION_EXPIRED */, () => {
        stopProfiling('session-expired').catch(browser_core_1.monitorError);
    });
    // Start the profiler again when session is renewed
    lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, () => {
        if (instance.state === 'stopped' && instance.stateReason === 'session-expired') {
            start(); // Only restart the profiler if it was stopped due to session expiration. Avoid restarting the profiler if it was stopped manually by the user.
        }
    });
    // Public API to start the profiler.
    function start() {
        if (instance.state === 'running') {
            return;
        }
        const viewEntry = viewHistory.findView();
        // Add initial view
        // Note: `viewEntry.name` is only filled when users use manual view creation via `startView` method.
        lastViewEntry = viewEntry
            ? {
                startClocks: viewEntry.startClocks,
                viewId: viewEntry.id,
                viewName: (0, getCustomOrDefaultViewName_1.getCustomOrDefaultViewName)(viewEntry.name, document.location.pathname),
            }
            : undefined;
        // Add global clean-up tasks for listeners that are not specific to a profiler instance (eg. visibility change, before unload)
        globalCleanupTasks.push((0, browser_core_1.addEventListener)(configuration, window, "visibilitychange" /* DOM_EVENT.VISIBILITY_CHANGE */, handleVisibilityChange).stop, (0, browser_core_1.addEventListener)(configuration, window, "beforeunload" /* DOM_EVENT.BEFORE_UNLOAD */, handleBeforeUnload).stop);
        // Start profiler instance
        startNextProfilerInstance();
    }
    // Public API to manually stop the profiler.
    async function stop() {
        await stopProfiling('stopped-by-user');
    }
    async function stopProfiling(reason) {
        // Stop current profiler instance
        await stopProfilerInstance(reason);
        // Cleanup global listeners
        globalCleanupTasks.forEach((task) => task());
        // Update Profiling status once the Profiler has been stopped.
        profilingContextManager.set({ status: 'stopped', error_reason: undefined });
    }
    /**
     * Whenever a new Profiler instance is started, we need to add event listeners to surroundings (RUM Events, Long Tasks, etc) to enrich the Profiler data.
     * If the instance is already running, we can keep the same event listeners.
     */
    function addEventListeners(existingInstance) {
        if (existingInstance.state === 'running') {
            // Instance is already running, so we can keep same event listeners.
            return {
                cleanupTasks: existingInstance.cleanupTasks,
            };
        }
        // Store clean-up tasks for this instance (tasks to be executed when the Profiler is stopped or paused.)
        const cleanupTasks = [];
        // Whenever the View is updated, we add a views entry to the profiler instance.
        const viewUpdatedSubscription = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, (view) => {
            const viewEntry = {
                viewId: view.id,
                // Note: `viewName` is only filled when users use manual view creation via `startView` method.
                viewName: (0, getCustomOrDefaultViewName_1.getCustomOrDefaultViewName)(view.name, document.location.pathname),
                startClocks: view.startClocks,
            };
            collectViewEntry(viewEntry);
            // Update last view entry
            lastViewEntry = viewEntry;
        });
        cleanupTasks.push(viewUpdatedSubscription.unsubscribe);
        return {
            cleanupTasks,
        };
    }
    function startNextProfilerInstance() {
        // These APIs might be unavailable in some browsers
        const globalThisProfiler = (0, browser_core_1.getGlobalObject)().Profiler;
        if (!globalThisProfiler) {
            profilingContextManager.set({ status: 'error', error_reason: 'not-supported-by-browser' });
            throw new Error('RUM Profiler is not supported in this browser.');
        }
        // Don't wait for data collection to start next instance
        collectProfilerInstance(instance).catch(browser_core_1.monitorError);
        const { cleanupTasks } = addEventListeners(instance);
        let profiler;
        try {
            // We have to create new Profiler each time we start a new instance
            profiler = new globalThisProfiler({
                sampleInterval: profilerConfiguration.sampleIntervalMs,
                // Keep buffer size at 1.5 times of minimum required to collect data for a profiling instance
                maxBufferSize: Math.round((profilerConfiguration.collectIntervalMs * 1.5) / profilerConfiguration.sampleIntervalMs),
            });
        }
        catch (e) {
            if (e instanceof Error && e.message.includes('disabled by Document Policy')) {
                // Missing Response Header (`js-profiling`) that is required to enable the profiler.
                // We should suggest the user to enable the Response Header in their server configuration.
                browser_core_1.display.warn('[DD_RUM] Profiler startup failed. Ensure your server includes the `Document-Policy: js-profiling` response header when serving HTML pages.', e);
                profilingContextManager.set({ status: 'error', error_reason: 'missing-document-policy-header' });
            }
            else {
                profilingContextManager.set({ status: 'error', error_reason: 'unexpected-exception' });
            }
            return;
        }
        profilingContextManager.set({ status: 'running', error_reason: undefined });
        // Kick-off the new instance
        instance = {
            state: 'running',
            startClocks: (0, browser_core_1.clocksNow)(),
            profiler,
            timeoutId: (0, browser_core_1.setTimeout)(startNextProfilerInstance, profilerConfiguration.collectIntervalMs),
            views: [],
            cleanupTasks,
            longTasks: [],
        };
        // Add last view entry
        collectViewEntry(lastViewEntry);
        // Add event handler case we overflow the buffer
        profiler.addEventListener('samplebufferfull', handleSampleBufferFull);
    }
    async function collectProfilerInstance(lastInstance) {
        if (lastInstance.state !== 'running') {
            return;
        }
        // Cleanup instance
        (0, browser_core_1.clearTimeout)(lastInstance.timeoutId);
        lastInstance.profiler.removeEventListener('samplebufferfull', handleSampleBufferFull);
        // Store instance data snapshot in local variables to use in async callback
        const { startClocks, views } = lastInstance;
        // Stop current profiler to get trace
        await lastInstance.profiler
            .stop()
            .then((trace) => {
            const endClocks = (0, browser_core_1.clocksNow)();
            const duration = (0, browser_core_1.elapsed)(startClocks.timeStamp, endClocks.timeStamp);
            const longTasks = longTaskContexts.findLongTasks(startClocks.relative, duration);
            const isBelowDurationThreshold = duration < profilerConfiguration.minProfileDurationMs;
            const isBelowSampleThreshold = (0, getNumberOfSamples_1.getNumberOfSamples)(trace.samples) < profilerConfiguration.minNumberOfSamples;
            if (longTasks.length === 0 && (isBelowDurationThreshold || isBelowSampleThreshold)) {
                // Skip very short profiles to reduce noise and cost, but keep them if they contain long tasks.
                return;
            }
            handleProfilerTrace(
            // Enrich trace with time and instance data
            Object.assign(trace, {
                startClocks,
                endClocks,
                clocksOrigin: (0, browser_core_1.clocksOrigin)(),
                longTasks,
                views,
                sampleInterval: profilerConfiguration.sampleIntervalMs,
            }));
        })
            .catch(browser_core_1.monitorError);
    }
    async function stopProfilerInstance(stateReason) {
        if (instance.state !== 'running') {
            return;
        }
        await onPauseOrStopProfilerInstance();
        instance = { state: 'stopped', stateReason };
    }
    async function pauseProfilerInstance() {
        if (instance.state !== 'running') {
            return;
        }
        await onPauseOrStopProfilerInstance();
        instance = { state: 'paused' };
    }
    async function onPauseOrStopProfilerInstance() {
        if (instance.state !== 'running') {
            return;
        }
        // Cleanup tasks
        instance.cleanupTasks.forEach((cleanupTask) => cleanupTask());
        await collectProfilerInstance(instance);
    }
    function collectViewEntry(viewEntry) {
        if (instance.state !== 'running' || !viewEntry) {
            return;
        }
        // Add entry to views
        instance.views.push(viewEntry);
    }
    function handleProfilerTrace(trace) {
        var _a;
        // Find current session to assign it to the Profile.
        const sessionId = (_a = session.findTrackedSession()) === null || _a === void 0 ? void 0 : _a.id;
        const payload = (0, assembly_1.assembleProfilingPayload)(trace, configuration, sessionId);
        void transport.send(payload);
    }
    function handleSampleBufferFull() {
        startNextProfilerInstance();
    }
    function handleVisibilityChange() {
        if (document.visibilityState === 'hidden' && instance.state === 'running') {
            // Pause when tab is hidden. We use paused state to distinguish between
            // paused by visibility change and stopped by user.
            // If profiler is paused by the visibility change, we should resume when
            // tab becomes visible again. That's not the case when user stops the profiler.
            pauseProfilerInstance().catch(browser_core_1.monitorError);
        }
        else if (document.visibilityState === 'visible' && instance.state === 'paused') {
            // Resume when tab becomes visible again
            startNextProfilerInstance();
        }
    }
    function handleBeforeUnload() {
        // `unload` can in some cases be triggered while the page is still active (link to a different protocol like mailto:).
        // We can immediately flush (by starting a new profiler instance) to make sure we receive the data, and at the same time keep the profiler active.
        // In case of the regular unload, the profiler will be shut down anyway.
        startNextProfilerInstance();
    }
    function isStopped() {
        return instance.state === 'stopped';
    }
    function isRunning() {
        return instance.state === 'running';
    }
    function isPaused() {
        return instance.state === 'paused';
    }
    return { start, stop, isStopped, isRunning, isPaused };
}
//# sourceMappingURL=profiler.js.map