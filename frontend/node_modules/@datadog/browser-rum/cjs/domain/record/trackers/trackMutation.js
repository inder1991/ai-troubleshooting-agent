"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackMutation = trackMutation;
exports.sortAddedAndMovedNodes = sortAddedAndMovedNodes;
exports.idsAreAssignedForNodeAndAncestors = idsAreAssignedForNodeAndAncestors;
const browser_core_1 = require("@datadog/browser-core");
const browser_rum_core_1 = require("@datadog/browser-rum-core");
const types_1 = require("../../../types");
const serialization_1 = require("../serialization");
const mutationBatch_1 = require("../mutationBatch");
const assembly_1 = require("../assembly");
/**
 * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload
 */
function trackMutation(target, emitRecord, emitStats, scope) {
    const MutationObserver = (0, browser_rum_core_1.getMutationObserverConstructor)();
    if (!MutationObserver) {
        return { stop: browser_core_1.noop, flush: browser_core_1.noop };
    }
    const mutationBatch = (0, mutationBatch_1.createMutationBatch)((mutations) => {
        (0, serialization_1.serializeInTransaction)(2 /* SerializationKind.INCREMENTAL_SNAPSHOT */, emitRecord, emitStats, scope, (transaction) => processMutations(mutations.concat(observer.takeRecords()), transaction));
    });
    const observer = new MutationObserver((0, browser_core_1.monitor)(mutationBatch.addMutations));
    observer.observe(target, {
        attributeOldValue: true,
        attributes: true,
        characterData: true,
        characterDataOldValue: true,
        childList: true,
        subtree: true,
    });
    return {
        stop: () => {
            observer.disconnect();
            mutationBatch.stop();
        },
        flush: () => {
            mutationBatch.flush();
        },
    };
}
function processMutations(mutations, transaction) {
    const nodePrivacyLevelCache = new Map();
    mutations
        .filter((mutation) => mutation.type === 'childList')
        .forEach((mutation) => {
        mutation.removedNodes.forEach((removedNode) => {
            traverseRemovedShadowDom(removedNode, transaction.scope.shadowRootsController.removeShadowRoot);
        });
    });
    // Discard any mutation with a 'target' node that:
    // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely
    // part of a mutation occurring in a parent Node
    // * should be hidden or ignored
    const filteredMutations = mutations.filter((mutation) => mutation.target.isConnected &&
        idsAreAssignedForNodeAndAncestors(mutation.target, transaction.scope.nodeIds) &&
        (0, browser_rum_core_1.getNodePrivacyLevel)(mutation.target, transaction.scope.configuration.defaultPrivacyLevel, nodePrivacyLevelCache) !== browser_rum_core_1.NodePrivacyLevel.HIDDEN);
    const { adds, removes, hasBeenSerialized } = processChildListMutations(filteredMutations.filter((mutation) => mutation.type === 'childList'), nodePrivacyLevelCache, transaction);
    const texts = processCharacterDataMutations(filteredMutations.filter((mutation) => mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)), nodePrivacyLevelCache, transaction);
    const attributes = processAttributesMutations(filteredMutations.filter((mutation) => mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)), nodePrivacyLevelCache, transaction);
    if (!texts.length && !attributes.length && !removes.length && !adds.length) {
        return;
    }
    transaction.add((0, assembly_1.assembleIncrementalSnapshot)(types_1.IncrementalSource.Mutation, {
        adds,
        removes,
        texts,
        attributes,
    }));
}
function processChildListMutations(mutations, nodePrivacyLevelCache, transaction) {
    // First, we iterate over mutations to collect:
    //
    // * nodes that have been added in the document and not removed by a subsequent mutation
    // * nodes that have been removed from the document but were not added in a previous mutation
    //
    // For this second category, we also collect their previous parent (mutation.target) because we'll
    // need it to emit a 'remove' mutation.
    //
    // Those two categories may overlap: if a node moved from a position to another, it is reported as
    // two mutation records, one with a "removedNodes" and the other with "addedNodes". In this case,
    // the node will be in both sets.
    const addedAndMovedNodes = new Set();
    const removedNodes = new Map();
    for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) => {
            addedAndMovedNodes.add(node);
        });
        mutation.removedNodes.forEach((node) => {
            if (!addedAndMovedNodes.has(node)) {
                removedNodes.set(node, mutation.target);
            }
            addedAndMovedNodes.delete(node);
        });
    }
    // Then, we sort nodes that are still in the document by topological order, for two reasons:
    //
    // * We will serialize each added nodes with their descendants. We don't want to serialize a node
    // twice, so we need to iterate over the parent nodes first and skip any node that is contained in
    // a precedent node.
    //
    // * To emit "add" mutations, we need references to the parent and potential next sibling of each
    // added node. So we need to iterate over the parent nodes first, and when multiple nodes are
    // siblings, we want to iterate from last to first. This will ensure that any "next" node is
    // already serialized and have an id.
    const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes);
    sortAddedAndMovedNodes(sortedAddedAndMovedNodes);
    // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized
    // node ids in a set to be able to skip subsequent related mutations.
    transaction.serializedNodeIds = new Set();
    const addedNodeMutations = [];
    for (const node of sortedAddedAndMovedNodes) {
        if (hasBeenSerialized(node)) {
            continue;
        }
        const parentNodePrivacyLevel = (0, browser_rum_core_1.getNodePrivacyLevel)(node.parentNode, transaction.scope.configuration.defaultPrivacyLevel, nodePrivacyLevelCache);
        if (parentNodePrivacyLevel === browser_rum_core_1.NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === browser_rum_core_1.NodePrivacyLevel.IGNORE) {
            continue;
        }
        const serializedNode = (0, serialization_1.serializeNode)(node, parentNodePrivacyLevel, transaction);
        if (!serializedNode) {
            continue;
        }
        const parentNode = (0, browser_rum_core_1.getParentNode)(node);
        addedNodeMutations.push({
            nextId: getNextSibling(node),
            parentId: transaction.scope.nodeIds.get(parentNode),
            node: serializedNode,
        });
    }
    // Finally, we emit remove mutations.
    const removedNodeMutations = [];
    removedNodes.forEach((parent, node) => {
        const parentId = transaction.scope.nodeIds.get(parent);
        const id = transaction.scope.nodeIds.get(node);
        if (parentId !== undefined && id !== undefined) {
            removedNodeMutations.push({ parentId, id });
        }
    });
    return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized };
    function hasBeenSerialized(node) {
        var _a;
        const id = transaction.scope.nodeIds.get(node);
        return id !== undefined && ((_a = transaction.serializedNodeIds) === null || _a === void 0 ? void 0 : _a.has(id));
    }
    function getNextSibling(node) {
        let nextSibling = node.nextSibling;
        while (nextSibling) {
            const id = transaction.scope.nodeIds.get(nextSibling);
            if (id !== undefined) {
                return id;
            }
            nextSibling = nextSibling.nextSibling;
        }
        return null;
    }
}
function processCharacterDataMutations(mutations, nodePrivacyLevelCache, transaction) {
    var _a;
    const textMutations = [];
    // Deduplicate mutations based on their target node
    const handledNodes = new Set();
    const filteredMutations = mutations.filter((mutation) => {
        if (handledNodes.has(mutation.target)) {
            return false;
        }
        handledNodes.add(mutation.target);
        return true;
    });
    // Emit mutations
    for (const mutation of filteredMutations) {
        const value = mutation.target.textContent;
        if (value === mutation.oldValue) {
            continue;
        }
        const id = transaction.scope.nodeIds.get(mutation.target);
        if (id === undefined) {
            continue;
        }
        const parentNodePrivacyLevel = (0, browser_rum_core_1.getNodePrivacyLevel)((0, browser_rum_core_1.getParentNode)(mutation.target), transaction.scope.configuration.defaultPrivacyLevel, nodePrivacyLevelCache);
        if (parentNodePrivacyLevel === browser_rum_core_1.NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === browser_rum_core_1.NodePrivacyLevel.IGNORE) {
            continue;
        }
        textMutations.push({
            id,
            value: (_a = (0, browser_rum_core_1.getTextContent)(mutation.target, parentNodePrivacyLevel)) !== null && _a !== void 0 ? _a : null,
        });
    }
    return textMutations;
}
function processAttributesMutations(mutations, nodePrivacyLevelCache, transaction) {
    const attributeMutations = [];
    // Deduplicate mutations based on their target node and changed attribute
    const handledElements = new Map();
    const filteredMutations = mutations.filter((mutation) => {
        const handledAttributes = handledElements.get(mutation.target);
        if (handledAttributes && handledAttributes.has(mutation.attributeName)) {
            return false;
        }
        if (!handledAttributes) {
            handledElements.set(mutation.target, new Set([mutation.attributeName]));
        }
        else {
            handledAttributes.add(mutation.attributeName);
        }
        return true;
    });
    // Emit mutations
    const emittedMutations = new Map();
    for (const mutation of filteredMutations) {
        const uncensoredValue = mutation.target.getAttribute(mutation.attributeName);
        if (uncensoredValue === mutation.oldValue) {
            continue;
        }
        const id = transaction.scope.nodeIds.get(mutation.target);
        if (id === undefined) {
            continue;
        }
        const privacyLevel = (0, browser_rum_core_1.getNodePrivacyLevel)(mutation.target, transaction.scope.configuration.defaultPrivacyLevel, nodePrivacyLevelCache);
        const attributeValue = (0, serialization_1.serializeAttribute)(mutation.target, privacyLevel, mutation.attributeName, transaction.scope.configuration);
        let transformedValue;
        if (mutation.attributeName === 'value') {
            const inputValue = (0, serialization_1.getElementInputValue)(mutation.target, privacyLevel);
            if (inputValue === undefined) {
                continue;
            }
            transformedValue = inputValue;
        }
        else if (typeof attributeValue === 'string') {
            transformedValue = attributeValue;
        }
        else {
            transformedValue = null;
        }
        let emittedMutation = emittedMutations.get(mutation.target);
        if (!emittedMutation) {
            emittedMutation = { id, attributes: {} };
            attributeMutations.push(emittedMutation);
            emittedMutations.set(mutation.target, emittedMutation);
        }
        emittedMutation.attributes[mutation.attributeName] = transformedValue;
    }
    return attributeMutations;
}
function sortAddedAndMovedNodes(nodes) {
    nodes.sort((a, b) => {
        const position = a.compareDocumentPosition(b);
        /* eslint-disable no-bitwise */
        if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
            return -1;
        }
        else if (position & Node.DOCUMENT_POSITION_CONTAINS) {
            return 1;
        }
        else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {
            return 1;
        }
        else if (position & Node.DOCUMENT_POSITION_PRECEDING) {
            return -1;
        }
        /* eslint-enable no-bitwise */
        return 0;
    });
}
function traverseRemovedShadowDom(removedNode, shadowDomRemovedCallback) {
    if ((0, browser_rum_core_1.isNodeShadowHost)(removedNode)) {
        shadowDomRemovedCallback(removedNode.shadowRoot);
    }
    (0, browser_rum_core_1.forEachChildNodes)(removedNode, (childNode) => traverseRemovedShadowDom(childNode, shadowDomRemovedCallback));
}
function idsAreAssignedForNodeAndAncestors(node, nodeIds) {
    let current = node;
    while (current) {
        if (nodeIds.get(current) === undefined && !(0, browser_rum_core_1.isNodeShadowRoot)(current)) {
            return false;
        }
        current = (0, browser_rum_core_1.getParentNode)(current);
    }
    return true;
}
//# sourceMappingURL=trackMutation.js.map