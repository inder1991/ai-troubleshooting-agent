"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeAttributes = serializeAttributes;
exports.serializeDOMAttributes = serializeDOMAttributes;
exports.serializeVirtualAttributes = serializeVirtualAttributes;
exports.getCssRulesString = getCssRulesString;
const browser_rum_core_1 = require("@datadog/browser-rum-core");
const browser_core_1 = require("@datadog/browser-core");
const serializationUtils_1 = require("./serializationUtils");
const serializeAttribute_1 = require("./serializeAttribute");
function serializeAttributes(element, nodePrivacyLevel, transaction) {
    return {
        ...serializeDOMAttributes(element, nodePrivacyLevel, transaction),
        ...serializeVirtualAttributes(element, nodePrivacyLevel, transaction),
    };
}
function serializeDOMAttributes(element, nodePrivacyLevel, transaction) {
    if (nodePrivacyLevel === browser_rum_core_1.NodePrivacyLevel.HIDDEN) {
        return {};
    }
    const attrs = {};
    const tagName = (0, serializationUtils_1.normalizedTagName)(element);
    for (let i = 0; i < element.attributes.length; i += 1) {
        const attribute = element.attributes.item(i);
        const attributeName = attribute.name;
        const attributeValue = (0, serializeAttribute_1.serializeAttribute)(element, nodePrivacyLevel, attributeName, transaction.scope.configuration);
        if (attributeValue !== null) {
            attrs[attributeName] = attributeValue;
        }
    }
    if (element.value &&
        (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')) {
        const formValue = (0, serializationUtils_1.getElementInputValue)(element, nodePrivacyLevel);
        if (formValue !== undefined) {
            attrs.value = formValue;
        }
    }
    /**
     * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`
     */
    if (tagName === 'option') {
        const optionElement = element;
        if (optionElement.selected && !(0, browser_rum_core_1.shouldMaskNode)(optionElement, nodePrivacyLevel)) {
            attrs.selected = '';
        }
        else {
            delete attrs.selected;
        }
    }
    /**
     * Forms: input[type=checkbox,radio]
     * The `checked` property for <input> is a little bit special:
     * 1. el.checked is a setter that returns if truthy.
     * 2. getAttribute returns the string value
     * getAttribute('checked') does not sync with `Element.checked`, so use JS property
     * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.
     */
    const inputElement = element;
    if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {
        if (inputElement.checked && !(0, browser_rum_core_1.shouldMaskNode)(inputElement, nodePrivacyLevel)) {
            attrs.checked = '';
        }
        else {
            delete attrs.checked;
        }
    }
    return attrs;
}
function serializeVirtualAttributes(element, nodePrivacyLevel, transaction) {
    if (nodePrivacyLevel === browser_rum_core_1.NodePrivacyLevel.HIDDEN) {
        return {};
    }
    const attrs = {};
    const doc = element.ownerDocument;
    const tagName = (0, serializationUtils_1.normalizedTagName)(element);
    // remote css
    if (tagName === 'link') {
        const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === element.href);
        const cssText = getCssRulesString(stylesheet);
        if (cssText && stylesheet) {
            transaction.addMetric('cssText', cssText.length);
            attrs._cssText = cssText;
        }
    }
    // dynamic stylesheet
    if (tagName === 'style' && element.sheet) {
        const cssText = getCssRulesString(element.sheet);
        if (cssText) {
            transaction.addMetric('cssText', cssText.length);
            attrs._cssText = cssText;
        }
    }
    /**
     * Serialize the media playback state
     */
    if (tagName === 'audio' || tagName === 'video') {
        const mediaElement = element;
        attrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played';
    }
    /**
     * Serialize the scroll state for each element only for full snapshot
     */
    let scrollTop;
    let scrollLeft;
    switch (transaction.kind) {
        case 0 /* SerializationKind.INITIAL_FULL_SNAPSHOT */:
            scrollTop = Math.round(element.scrollTop);
            scrollLeft = Math.round(element.scrollLeft);
            if (scrollTop || scrollLeft) {
                transaction.scope.elementsScrollPositions.set(element, { scrollTop, scrollLeft });
            }
            break;
        case 1 /* SerializationKind.SUBSEQUENT_FULL_SNAPSHOT */:
            if (transaction.scope.elementsScrollPositions.has(element)) {
                ;
                ({ scrollTop, scrollLeft } = transaction.scope.elementsScrollPositions.get(element));
            }
            break;
    }
    if (scrollLeft) {
        attrs.rr_scrollLeft = scrollLeft;
    }
    if (scrollTop) {
        attrs.rr_scrollTop = scrollTop;
    }
    return attrs;
}
function getCssRulesString(cssStyleSheet) {
    if (!cssStyleSheet) {
        return null;
    }
    let rules;
    try {
        rules = cssStyleSheet.rules || cssStyleSheet.cssRules;
    }
    catch (_a) {
        // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface
    }
    if (!rules) {
        return null;
    }
    const styleSheetCssText = Array.from(rules, (0, browser_core_1.isSafari)() ? getCssRuleStringForSafari : getCssRuleString).join('');
    return (0, serializationUtils_1.switchToAbsoluteUrl)(styleSheetCssText, cssStyleSheet.href);
}
function getCssRuleStringForSafari(rule) {
    // Safari does not escape attribute selectors containing : properly
    // https://bugs.webkit.org/show_bug.cgi?id=184604
    if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {
        // This regex replaces [foo:bar] by [foo\\:bar]
        const escapeColon = /(\[[\w-]+[^\\])(:[^\]]+\])/g;
        return rule.cssText.replace(escapeColon, '$1\\$2');
    }
    return getCssRuleString(rule);
}
function getCssRuleString(rule) {
    // If it's an @import rule, try to inline sub-rules recursively with `getCssRulesString`. This
    // operation can fail if the imported stylesheet is protected by CORS, in which case we fallback
    // to the @import rule CSS text.
    return (isCSSImportRule(rule) && getCssRulesString(rule.styleSheet)) || rule.cssText;
}
function isCSSImportRule(rule) {
    return 'styleSheet' in rule;
}
function isCSSStyleRule(rule) {
    return 'selectorText' in rule;
}
//# sourceMappingURL=serializeAttributes.js.map