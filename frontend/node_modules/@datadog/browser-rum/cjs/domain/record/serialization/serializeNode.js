"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeNode = serializeNode;
exports.serializeChildNodes = serializeChildNodes;
exports.serializeDocumentNode = serializeDocumentNode;
const browser_rum_core_1 = require("@datadog/browser-rum-core");
const types_1 = require("../../../types");
const serializationUtils_1 = require("./serializationUtils");
const serializeStyleSheets_1 = require("./serializeStyleSheets");
const serializeAttributes_1 = require("./serializeAttributes");
function serializeNode(node, parentNodePrivacyLevel, transaction) {
    switch (node.nodeType) {
        case node.DOCUMENT_NODE:
            return serializeDocumentNode(node, parentNodePrivacyLevel, transaction);
        case node.DOCUMENT_FRAGMENT_NODE:
            return serializeDocumentFragmentNode(node, parentNodePrivacyLevel, transaction);
        case node.DOCUMENT_TYPE_NODE:
            return serializeDocumentTypeNode(node, transaction);
        case node.ELEMENT_NODE:
            return serializeElementNode(node, parentNodePrivacyLevel, transaction);
        case node.TEXT_NODE:
            return serializeTextNode(node, parentNodePrivacyLevel, transaction);
        case node.CDATA_SECTION_NODE:
            return serializeCDataNode(node, transaction);
        default:
            return null;
    }
}
function serializeChildNodes(node, parentNodePrivacyLevel, transaction) {
    const result = [];
    (0, browser_rum_core_1.forEachChildNodes)(node, (childNode) => {
        const serializedChildNode = serializeNode(childNode, parentNodePrivacyLevel, transaction);
        if (serializedChildNode) {
            result.push(serializedChildNode);
        }
    });
    return result;
}
function serializeDocumentNode(document, parentNodePrivacyLevel, transaction) {
    return {
        type: types_1.NodeType.Document,
        id: transaction.assignId(document),
        childNodes: serializeChildNodes(document, parentNodePrivacyLevel, transaction),
        adoptedStyleSheets: (0, serializeStyleSheets_1.serializeStyleSheets)(document.adoptedStyleSheets),
    };
}
function serializeDocumentFragmentNode(element, parentNodePrivacyLevel, transaction) {
    const isShadowRoot = (0, browser_rum_core_1.isNodeShadowRoot)(element);
    if (isShadowRoot) {
        transaction.scope.shadowRootsController.addShadowRoot(element, transaction.scope);
    }
    return {
        type: types_1.NodeType.DocumentFragment,
        id: transaction.assignId(element),
        childNodes: serializeChildNodes(element, parentNodePrivacyLevel, transaction),
        isShadowRoot,
        adoptedStyleSheets: isShadowRoot ? (0, serializeStyleSheets_1.serializeStyleSheets)(element.adoptedStyleSheets) : undefined,
    };
}
function serializeDocumentTypeNode(documentType, transaction) {
    return {
        type: types_1.NodeType.DocumentType,
        id: transaction.assignId(documentType),
        name: documentType.name,
        publicId: documentType.publicId,
        systemId: documentType.systemId,
    };
}
/**
 * Serializing Element nodes involves capturing:
 * 1. HTML ATTRIBUTES:
 * 2. JS STATE:
 * - scroll offsets
 * - Form fields (input value, checkbox checked, option selection, range)
 * - Canvas state,
 * - Media (video/audio) play mode + currentTime
 * - iframe contents
 * - webcomponents
 * 3. CUSTOM PROPERTIES:
 * - height+width for when `hidden` to cover the element
 * 4. EXCLUDED INTERACTION STATE:
 * - focus (possible, but not worth perf impact)
 * - hover (tracked only via mouse activity)
 * - fullscreen mode
 */
function serializeElementNode(element, parentNodePrivacyLevel, transaction) {
    const tagName = (0, serializationUtils_1.getValidTagName)(element.tagName);
    const isSVG = isSVGElement(element) || undefined;
    // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the
    // parentNodePrivacyLevel option to avoid iterating over all parents
    const nodePrivacyLevel = (0, browser_rum_core_1.reducePrivacyLevel)((0, browser_rum_core_1.getNodeSelfPrivacyLevel)(element), parentNodePrivacyLevel);
    if (nodePrivacyLevel === browser_rum_core_1.NodePrivacyLevel.HIDDEN) {
        const { width, height } = element.getBoundingClientRect();
        return {
            type: types_1.NodeType.Element,
            id: transaction.assignId(element),
            tagName,
            attributes: {
                rr_width: `${width}px`,
                rr_height: `${height}px`,
                [browser_rum_core_1.PRIVACY_ATTR_NAME]: browser_rum_core_1.PRIVACY_ATTR_VALUE_HIDDEN,
            },
            childNodes: [],
            isSVG,
        };
    }
    // Ignore Elements like Script and some Link, Metas
    if (nodePrivacyLevel === browser_rum_core_1.NodePrivacyLevel.IGNORE) {
        return null;
    }
    const id = transaction.assignId(element);
    const attributes = (0, serializeAttributes_1.serializeAttributes)(element, nodePrivacyLevel, transaction);
    let childNodes = [];
    if ((0, browser_rum_core_1.hasChildNodes)(element) &&
        // Do not serialize style children as the css rules are already in the _cssText attribute
        tagName !== 'style') {
        childNodes = serializeChildNodes(element, nodePrivacyLevel, transaction);
    }
    return {
        type: types_1.NodeType.Element,
        id,
        tagName,
        attributes,
        childNodes,
        isSVG,
    };
}
function isSVGElement(el) {
    return el.tagName === 'svg' || el instanceof SVGElement;
}
/**
 * Text Nodes are dependant on Element nodes
 * Privacy levels are set on elements so we check the parentElement of a text node
 * for privacy level.
 */
function serializeTextNode(textNode, parentNodePrivacyLevel, transaction) {
    const textContent = (0, browser_rum_core_1.getTextContent)(textNode, parentNodePrivacyLevel);
    if (textContent === undefined) {
        return null;
    }
    return {
        type: types_1.NodeType.Text,
        id: transaction.assignId(textNode),
        textContent,
    };
}
function serializeCDataNode(node, transaction) {
    return {
        type: types_1.NodeType.CDATA,
        id: transaction.assignId(node),
        textContent: '',
    };
}
//# sourceMappingURL=serializeNode.js.map