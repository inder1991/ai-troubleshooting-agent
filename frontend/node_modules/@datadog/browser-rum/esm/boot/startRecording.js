import { createHttpRequest, addTelemetryDebug, canUseEventBridge, noop } from '@datadog/browser-core';
import { record } from '../domain/record';
import { startSegmentCollection, SEGMENT_BYTES_LIMIT, startSegmentTelemetry } from '../domain/segmentCollection';
import { startRecordBridge } from '../domain/startRecordBridge';
export function startRecording(lifeCycle, configuration, sessionManager, viewHistory, encoder, telemetry, httpRequest) {
    const cleanupTasks = [];
    const reportError = (error) => {
        lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error });
        // monitor-until: forever, to keep an eye on the errors reported to customers
        addTelemetryDebug('Error reported to customer', { 'error.message': error.message });
    };
    const replayRequest = httpRequest || createHttpRequest([configuration.sessionReplayEndpointBuilder], reportError, SEGMENT_BYTES_LIMIT);
    let addRecord;
    let addStats;
    if (!canUseEventBridge()) {
        const segmentCollection = startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, replayRequest, encoder);
        addRecord = segmentCollection.addRecord;
        addStats = segmentCollection.addStats;
        cleanupTasks.push(segmentCollection.stop);
        const segmentTelemetry = startSegmentTelemetry(telemetry, replayRequest.observable);
        cleanupTasks.push(segmentTelemetry.stop);
    }
    else {
        ;
        ({ addRecord } = startRecordBridge(viewHistory));
        addStats = noop;
    }
    const { stop: stopRecording } = record({
        emitRecord: addRecord,
        emitStats: addStats,
        configuration,
        lifeCycle,
        viewHistory,
    });
    cleanupTasks.push(stopRecording);
    return {
        stop: () => {
            cleanupTasks.forEach((task) => task());
        },
    };
}
//# sourceMappingURL=startRecording.js.map