import { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core';
import { buildReplayPayload } from './buildReplayPayload';
import { createSegment } from './segment';
export const SEGMENT_DURATION_LIMIT = 5 * ONE_SECOND;
/**
 * beacon payload max queue size implementation is 64kb
 * ensure that we leave room for logs, rum and potential other users
 */
export let SEGMENT_BYTES_LIMIT = 60000;
export function startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, httpRequest, encoder) {
    return doStartSegmentCollection(lifeCycle, () => computeSegmentContext(configuration.applicationId, sessionManager, viewHistory), httpRequest, encoder);
}
export function doStartSegmentCollection(lifeCycle, getSegmentContext, httpRequest, encoder) {
    let state = {
        status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,
        nextSegmentCreationReason: 'init',
    };
    const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, () => {
        flushSegment('view_change');
    });
    const { unsubscribe: unsubscribePageMayExit } = lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_MAY_EXIT */, (pageMayExitEvent) => {
        flushSegment(pageMayExitEvent.reason);
    });
    function flushSegment(flushReason) {
        if (state.status === 1 /* SegmentCollectionStatus.SegmentPending */) {
            state.segment.flush((metadata, stats, encoderResult) => {
                const payload = buildReplayPayload(encoderResult.output, metadata, stats, encoderResult.rawBytesCount);
                if (isPageExitReason(flushReason)) {
                    httpRequest.sendOnExit(payload);
                }
                else {
                    httpRequest.send(payload);
                }
            });
            clearTimeout(state.expirationTimeoutId);
        }
        if (flushReason !== 'stop') {
            state = {
                status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,
                nextSegmentCreationReason: flushReason,
            };
        }
        else {
            state = {
                status: 2 /* SegmentCollectionStatus.Stopped */,
            };
        }
    }
    return {
        addRecord: (record) => {
            if (state.status === 2 /* SegmentCollectionStatus.Stopped */) {
                return;
            }
            if (state.status === 0 /* SegmentCollectionStatus.WaitingForInitialRecord */) {
                const context = getSegmentContext();
                if (!context) {
                    return;
                }
                state = {
                    status: 1 /* SegmentCollectionStatus.SegmentPending */,
                    segment: createSegment({ encoder, context, creationReason: state.nextSegmentCreationReason }),
                    expirationTimeoutId: setTimeout(() => {
                        flushSegment('segment_duration_limit');
                    }, SEGMENT_DURATION_LIMIT),
                };
            }
            state.segment.addRecord(record, (encodedBytesCount) => {
                if (encodedBytesCount > SEGMENT_BYTES_LIMIT) {
                    flushSegment('segment_bytes_limit');
                }
            });
        },
        addStats: (stats) => {
            if (state.status === 1 /* SegmentCollectionStatus.SegmentPending */) {
                state.segment.addStats(stats);
            }
        },
        stop: () => {
            flushSegment('stop');
            unsubscribeViewCreated();
            unsubscribePageMayExit();
        },
    };
}
export function computeSegmentContext(applicationId, sessionManager, viewHistory) {
    const session = sessionManager.findTrackedSession();
    const viewContext = viewHistory.findView();
    if (!session || !viewContext) {
        return undefined;
    }
    return {
        application: {
            id: applicationId,
        },
        session: {
            id: session.id,
        },
        view: {
            id: viewContext.id,
        },
    };
}
export function setSegmentBytesLimit(newSegmentBytesLimit = 60000) {
    SEGMENT_BYTES_LIMIT = newSegmentBytesLimit;
}
//# sourceMappingURL=segmentCollection.js.map