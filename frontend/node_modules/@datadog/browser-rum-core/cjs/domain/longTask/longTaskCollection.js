"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LONG_TASK_ID_HISTORY_TIME_OUT_DELAY = void 0;
exports.startLongTaskCollection = startLongTaskCollection;
const browser_core_1 = require("@datadog/browser-core");
const rawRumEvent_types_1 = require("../../rawRumEvent.types");
const performanceObservable_1 = require("../../browser/performanceObservable");
exports.LONG_TASK_ID_HISTORY_TIME_OUT_DELAY = browser_core_1.SESSION_TIME_OUT_DELAY;
function startLongTaskCollection(lifeCycle, configuration) {
    const history = (0, browser_core_1.createValueHistory)({
        expireDelay: exports.LONG_TASK_ID_HISTORY_TIME_OUT_DELAY,
    });
    const entryType = (0, performanceObservable_1.supportPerformanceTimingEvent)(performanceObservable_1.RumPerformanceEntryType.LONG_ANIMATION_FRAME)
        ? performanceObservable_1.RumPerformanceEntryType.LONG_ANIMATION_FRAME
        : performanceObservable_1.RumPerformanceEntryType.LONG_TASK;
    const subscription = (0, performanceObservable_1.createPerformanceObservable)(configuration, {
        type: entryType,
        buffered: true,
    }).subscribe((entries) => {
        for (const entry of entries) {
            if (!configuration.trackLongTasks) {
                break;
            }
            const startClocks = (0, browser_core_1.relativeToClocks)(entry.startTime);
            const taskId = (0, browser_core_1.generateUUID)();
            const rawRumEvent = processEntry(entry, startClocks, taskId);
            lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, {
                rawRumEvent,
                startTime: startClocks.relative,
                duration: entry.duration,
                domainContext: { performanceEntry: entry },
            });
            history.add({ id: taskId, startClocks, duration: entry.duration, entryType }, startClocks.relative);
            history.closeActive((0, browser_core_1.addDuration)(startClocks.relative, entry.duration));
        }
    });
    const longTaskContexts = {
        findLongTasks: (startTime, duration) => history.findAll(startTime, duration),
    };
    return {
        stop: () => {
            subscription.unsubscribe();
            history.stop();
        },
        longTaskContexts,
    };
}
function processEntry(entry, startClocks, taskId) {
    const baseEvent = {
        date: startClocks.timeStamp,
        type: rawRumEvent_types_1.RumEventType.LONG_TASK,
        _dd: { discarded: false },
    };
    if (entry.entryType === performanceObservable_1.RumPerformanceEntryType.LONG_TASK) {
        return {
            ...baseEvent,
            long_task: {
                id: taskId,
                entry_type: rawRumEvent_types_1.RumLongTaskEntryType.LONG_TASK,
                duration: (0, browser_core_1.toServerDuration)(entry.duration),
            },
        };
    }
    return {
        ...baseEvent,
        long_task: {
            id: taskId,
            entry_type: rawRumEvent_types_1.RumLongTaskEntryType.LONG_ANIMATION_FRAME,
            duration: (0, browser_core_1.toServerDuration)(entry.duration),
            blocking_duration: (0, browser_core_1.toServerDuration)(entry.blockingDuration),
            first_ui_event_timestamp: (0, browser_core_1.toServerDuration)(entry.firstUIEventTimestamp),
            render_start: (0, browser_core_1.toServerDuration)(entry.renderStart),
            style_and_layout_start: (0, browser_core_1.toServerDuration)(entry.styleAndLayoutStart),
            start_time: (0, browser_core_1.toServerDuration)(entry.startTime),
            scripts: entry.scripts.map((script) => ({
                duration: (0, browser_core_1.toServerDuration)(script.duration),
                pause_duration: (0, browser_core_1.toServerDuration)(script.pauseDuration),
                forced_style_and_layout_duration: (0, browser_core_1.toServerDuration)(script.forcedStyleAndLayoutDuration),
                start_time: (0, browser_core_1.toServerDuration)(script.startTime),
                execution_start: (0, browser_core_1.toServerDuration)(script.executionStart),
                source_url: script.sourceURL,
                source_function_name: script.sourceFunctionName,
                source_char_position: script.sourceCharPosition,
                invoker: script.invoker,
                invoker_type: script.invokerType,
                window_attribution: script.windowAttribution,
            })),
        },
    };
}
//# sourceMappingURL=longTaskCollection.js.map