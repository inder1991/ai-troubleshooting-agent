"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LONG_TASK_START_TIME_CORRECTION = void 0;
exports.startActionCollection = startActionCollection;
const browser_core_1 = require("@datadog/browser-core");
const discardNegativeDuration_1 = require("../discardNegativeDuration");
const rawRumEvent_types_1 = require("../../rawRumEvent.types");
const trackClickActions_1 = require("./trackClickActions");
exports.LONG_TASK_START_TIME_CORRECTION = 1;
function startActionCollection(lifeCycle, hooks, domMutationObservable, windowOpenObservable, configuration) {
    const { unsubscribe: unsubscribeAutoAction } = lifeCycle.subscribe(0 /* LifeCycleEventType.AUTO_ACTION_COMPLETED */, (action) => {
        lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, processAction(action));
    });
    hooks.register(0 /* HookNames.Assemble */, ({ startTime, eventType }) => {
        if (eventType !== rawRumEvent_types_1.RumEventType.ERROR &&
            eventType !== rawRumEvent_types_1.RumEventType.RESOURCE &&
            eventType !== rawRumEvent_types_1.RumEventType.LONG_TASK) {
            return browser_core_1.SKIPPED;
        }
        // Long tasks triggered by interaction handlers (pointerup, click, etc.)
        // can have a start time slightly before the interaction timestamp (long_task.start_time < action.start_time).
        // This likely happens because the interaction timestamp is recorded during the event dispatch,
        // not at the beginning of the rendering frame. I observed a difference of < 1 ms in my tests.
        // Fixes flakiness in test: "associates long tasks to interaction actions"
        const correctedStartTime = eventType === rawRumEvent_types_1.RumEventType.LONG_TASK ? (0, browser_core_1.addDuration)(startTime, exports.LONG_TASK_START_TIME_CORRECTION) : startTime;
        const actionId = actionContexts.findActionId(correctedStartTime);
        if (!actionId) {
            return browser_core_1.SKIPPED;
        }
        return {
            type: eventType,
            action: { id: actionId },
        };
    });
    hooks.register(1 /* HookNames.AssembleTelemetry */, ({ startTime }) => ({
        action: { id: actionContexts.findActionId(startTime) },
    }));
    let actionContexts = { findActionId: browser_core_1.noop };
    let stop = browser_core_1.noop;
    if (configuration.trackUserInteractions) {
        ;
        ({ actionContexts, stop } = (0, trackClickActions_1.trackClickActions)(lifeCycle, domMutationObservable, windowOpenObservable, configuration));
    }
    return {
        addAction: (action) => {
            lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, processAction(action));
        },
        actionContexts,
        stop: () => {
            unsubscribeAutoAction();
            stop();
        },
    };
}
function processAction(action) {
    const autoActionProperties = isAutoAction(action)
        ? {
            action: {
                id: action.id,
                loading_time: (0, discardNegativeDuration_1.discardNegativeDuration)((0, browser_core_1.toServerDuration)(action.duration)),
                frustration: {
                    type: action.frustrationTypes,
                },
                error: {
                    count: action.counts.errorCount,
                },
                long_task: {
                    count: action.counts.longTaskCount,
                },
                resource: {
                    count: action.counts.resourceCount,
                },
            },
            _dd: {
                action: {
                    target: action.target,
                    position: action.position,
                    name_source: action.nameSource,
                },
            },
        }
        : {
            context: action.context,
        };
    const actionEvent = (0, browser_core_1.combine)({
        action: { id: (0, browser_core_1.generateUUID)(), target: { name: action.name }, type: action.type },
        date: action.startClocks.timeStamp,
        type: rawRumEvent_types_1.RumEventType.ACTION,
    }, autoActionProperties);
    const duration = isAutoAction(action) ? action.duration : undefined;
    const domainContext = isAutoAction(action)
        ? { events: action.events }
        : { handlingStack: action.handlingStack };
    return {
        rawRumEvent: actionEvent,
        duration,
        startTime: action.startClocks.relative,
        domainContext,
    };
}
function isAutoAction(action) {
    return action.type !== rawRumEvent_types_1.ActionType.CUSTOM;
}
//# sourceMappingURL=actionCollection.js.map