"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startResourceCollection = startResourceCollection;
const browser_core_1 = require("@datadog/browser-core");
const performanceObservable_1 = require("../../browser/performanceObservable");
const rawRumEvent_types_1 = require("../../rawRumEvent.types");
const identifier_1 = require("../tracing/identifier");
const matchRequestResourceEntry_1 = require("./matchRequestResourceEntry");
const resourceUtils_1 = require("./resourceUtils");
const retrieveInitialDocumentResourceTiming_1 = require("./retrieveInitialDocumentResourceTiming");
const requestRegistry_1 = require("./requestRegistry");
const graphql_1 = require("./graphql");
function startResourceCollection(lifeCycle, configuration, pageStateHistory, taskQueue = (0, browser_core_1.createTaskQueue)(), retrieveInitialDocumentResourceTimingImpl = retrieveInitialDocumentResourceTiming_1.retrieveInitialDocumentResourceTiming) {
    let requestRegistry;
    const isEarlyRequestCollectionEnabled = configuration.trackEarlyRequests;
    if (isEarlyRequestCollectionEnabled) {
        requestRegistry = (0, requestRegistry_1.createRequestRegistry)(lifeCycle);
    }
    else {
        lifeCycle.subscribe(8 /* LifeCycleEventType.REQUEST_COMPLETED */, (request) => {
            handleResource(() => processRequest(request, configuration, pageStateHistory));
        });
    }
    const performanceResourceSubscription = (0, performanceObservable_1.createPerformanceObservable)(configuration, {
        type: performanceObservable_1.RumPerformanceEntryType.RESOURCE,
        buffered: true,
    }).subscribe((entries) => {
        for (const entry of entries) {
            if (isEarlyRequestCollectionEnabled || !(0, resourceUtils_1.isResourceEntryRequestType)(entry)) {
                handleResource(() => processResourceEntry(entry, configuration, pageStateHistory, requestRegistry));
            }
        }
    });
    retrieveInitialDocumentResourceTimingImpl(configuration, (timing) => {
        handleResource(() => processResourceEntry(timing, configuration, pageStateHistory, requestRegistry));
    });
    function handleResource(computeRawEvent) {
        taskQueue.push(() => {
            const rawEvent = computeRawEvent();
            if (rawEvent) {
                lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, rawEvent);
            }
        });
    }
    return {
        stop: () => {
            taskQueue.stop();
            performanceResourceSubscription.unsubscribe();
        },
    };
}
function processRequest(request, configuration, pageStateHistory) {
    const matchingTiming = (0, matchRequestResourceEntry_1.matchRequestResourceEntry)(request);
    return assembleResource(matchingTiming, request, pageStateHistory, configuration);
}
function processResourceEntry(entry, configuration, pageStateHistory, requestRegistry) {
    const matchingRequest = (0, resourceUtils_1.isResourceEntryRequestType)(entry) && requestRegistry ? requestRegistry.getMatchingRequest(entry) : undefined;
    return assembleResource(entry, matchingRequest, pageStateHistory, configuration);
}
// TODO: In the future, the `entry` parameter should be required, making things simpler.
function assembleResource(entry, request, pageStateHistory, configuration) {
    if (!entry && !request) {
        return;
    }
    const tracingInfo = request
        ? computeRequestTracingInfo(request, configuration)
        : computeResourceEntryTracingInfo(entry, configuration);
    if (!configuration.trackResources && !tracingInfo) {
        return;
    }
    const startClocks = entry ? (0, browser_core_1.relativeToClocks)(entry.startTime) : request.startClocks;
    const duration = entry
        ? (0, resourceUtils_1.computeResourceEntryDuration)(entry)
        : computeRequestDuration(pageStateHistory, startClocks, request.duration);
    const graphql = request && computeGraphQlMetaData(request, configuration);
    const resourceEvent = (0, browser_core_1.combine)({
        date: startClocks.timeStamp,
        resource: {
            id: (0, browser_core_1.generateUUID)(),
            duration: (0, browser_core_1.toServerDuration)(duration),
            // TODO: in the future when `entry` is required, we can probably only rely on `computeResourceEntryType`
            type: request
                ? request.type === browser_core_1.RequestType.XHR
                    ? browser_core_1.ResourceType.XHR
                    : browser_core_1.ResourceType.FETCH
                : (0, resourceUtils_1.computeResourceEntryType)(entry),
            method: request ? request.method : undefined,
            status_code: request ? request.status : discardZeroStatus(entry.responseStatus),
            url: request ? (0, resourceUtils_1.sanitizeIfLongDataUrl)(request.url) : entry.name,
            protocol: entry && (0, resourceUtils_1.computeResourceEntryProtocol)(entry),
            delivery_type: entry && (0, resourceUtils_1.computeResourceEntryDeliveryType)(entry),
            graphql,
        },
        type: rawRumEvent_types_1.RumEventType.RESOURCE,
        _dd: {
            discarded: !configuration.trackResources,
        },
    }, tracingInfo, entry && computeResourceEntryMetrics(entry));
    return {
        startTime: startClocks.relative,
        duration,
        rawRumEvent: resourceEvent,
        domainContext: getResourceDomainContext(entry, request),
    };
}
function computeGraphQlMetaData(request, configuration) {
    const graphQlConfig = (0, graphql_1.findGraphQlConfiguration)(request.url, configuration);
    if (!graphQlConfig) {
        return;
    }
    return (0, graphql_1.extractGraphQlMetadata)(request, graphQlConfig);
}
function getResourceDomainContext(entry, request) {
    if (request) {
        const baseDomainContext = {
            performanceEntry: entry,
            isAborted: request.isAborted,
            handlingStack: request.handlingStack,
        };
        if (request.type === browser_core_1.RequestType.XHR) {
            return {
                xhr: request.xhr,
                ...baseDomainContext,
            };
        }
        return {
            requestInput: request.input,
            requestInit: request.init,
            response: request.response,
            error: request.error,
            ...baseDomainContext,
        };
    }
    return {
        // Currently, at least one of `entry` or `request` must be defined when calling this function.
        // So `entry` is guaranteed to be defined here. In the future, when `entry` is required, we can
        // remove the `!` assertion.
        performanceEntry: entry,
    };
}
function computeResourceEntryMetrics(entry) {
    const { renderBlockingStatus } = entry;
    return {
        resource: {
            render_blocking_status: renderBlockingStatus,
            ...(0, resourceUtils_1.computeResourceEntrySize)(entry),
            ...(0, resourceUtils_1.computeResourceEntryDetails)(entry),
        },
    };
}
function computeRequestTracingInfo(request, configuration) {
    const hasBeenTraced = request.traceSampled && request.traceId && request.spanId;
    if (!hasBeenTraced) {
        return undefined;
    }
    return {
        _dd: {
            span_id: request.spanId.toString(),
            trace_id: request.traceId.toString(),
            rule_psr: configuration.rulePsr,
        },
    };
}
function computeResourceEntryTracingInfo(entry, configuration) {
    const hasBeenTraced = entry.traceId;
    if (!hasBeenTraced) {
        return undefined;
    }
    return {
        _dd: {
            trace_id: entry.traceId,
            span_id: (0, identifier_1.createSpanIdentifier)().toString(),
            rule_psr: configuration.rulePsr,
        },
    };
}
function computeRequestDuration(pageStateHistory, startClocks, duration) {
    return !pageStateHistory.wasInPageStateDuringPeriod("frozen" /* PageState.FROZEN */, startClocks.relative, duration)
        ? duration
        : undefined;
}
/**
 * The status is 0 for cross-origin resources without CORS headers, so the status is meaningless, and we shouldn't report it
 * https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/responseStatus#cross-origin_response_status_codes
 */
function discardZeroStatus(statusCode) {
    return statusCode === 0 ? undefined : statusCode;
}
//# sourceMappingURL=resourceCollection.js.map