"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startRum = startRum;
exports.startRumEventCollection = startRumEventCollection;
const browser_core_1 = require("@datadog/browser-core");
const domMutationObservable_1 = require("../browser/domMutationObservable");
const windowOpenObservable_1 = require("../browser/windowOpenObservable");
const internalContext_1 = require("../domain/contexts/internalContext");
const lifeCycle_1 = require("../domain/lifeCycle");
const viewHistory_1 = require("../domain/contexts/viewHistory");
const requestCollection_1 = require("../domain/requestCollection");
const actionCollection_1 = require("../domain/action/actionCollection");
const errorCollection_1 = require("../domain/error/errorCollection");
const resourceCollection_1 = require("../domain/resource/resourceCollection");
const viewCollection_1 = require("../domain/view/viewCollection");
const rumSessionManager_1 = require("../domain/rumSessionManager");
const startRumBatch_1 = require("../transport/startRumBatch");
const startRumEventBridge_1 = require("../transport/startRumEventBridge");
const urlContexts_1 = require("../domain/contexts/urlContexts");
const locationChangeObservable_1 = require("../browser/locationChangeObservable");
const featureFlagContext_1 = require("../domain/contexts/featureFlagContext");
const startCustomerDataTelemetry_1 = require("../domain/startCustomerDataTelemetry");
const pageStateHistory_1 = require("../domain/contexts/pageStateHistory");
const displayContext_1 = require("../domain/contexts/displayContext");
const vitalCollection_1 = require("../domain/vital/vitalCollection");
const ciVisibilityContext_1 = require("../domain/contexts/ciVisibilityContext");
const longTaskCollection_1 = require("../domain/longTask/longTaskCollection");
const syntheticsContext_1 = require("../domain/contexts/syntheticsContext");
const assembly_1 = require("../domain/assembly");
const sessionContext_1 = require("../domain/contexts/sessionContext");
const connectivityContext_1 = require("../domain/contexts/connectivityContext");
const defaultContext_1 = require("../domain/contexts/defaultContext");
const trackingConsentContext_1 = require("../domain/contexts/trackingConsentContext");
const hooks_1 = require("../domain/hooks");
const eventCollection_1 = require("../domain/event/eventCollection");
const startInitialViewMetricsTelemetry_1 = require("../domain/view/viewMetrics/startInitialViewMetricsTelemetry");
function startRum(configuration, recorderApi, profilerApi, initialViewOptions, createEncoder, 
// `startRum` and its subcomponents assume tracking consent is granted initially and starts
// collecting logs unconditionally. As such, `startRum` should be called with a
// `trackingConsentState` set to "granted".
trackingConsentState, customVitalsState, bufferedDataObservable, sdkName) {
    const cleanupTasks = [];
    const lifeCycle = new lifeCycle_1.LifeCycle();
    const hooks = (0, hooks_1.createHooks)();
    lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, (event) => (0, browser_core_1.sendToExtension)('rum', event));
    const reportError = (error) => {
        lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error });
        // monitor-until: forever, to keep an eye on the errors reported to customers
        (0, browser_core_1.addTelemetryDebug)('Error reported to customer', { 'error.message': error.message });
    };
    const pageMayExitObservable = (0, browser_core_1.createPageMayExitObservable)(configuration);
    const pageMayExitSubscription = pageMayExitObservable.subscribe((event) => {
        lifeCycle.notify(11 /* LifeCycleEventType.PAGE_MAY_EXIT */, event);
    });
    cleanupTasks.push(() => pageMayExitSubscription.unsubscribe());
    const telemetry = (0, browser_core_1.startTelemetry)("browser-rum-sdk" /* TelemetryService.RUM */, configuration, hooks, reportError, pageMayExitObservable, createEncoder);
    cleanupTasks.push(telemetry.stop);
    const session = !(0, browser_core_1.canUseEventBridge)()
        ? (0, rumSessionManager_1.startRumSessionManager)(configuration, lifeCycle, trackingConsentState)
        : (0, rumSessionManager_1.startRumSessionManagerStub)();
    if (!(0, browser_core_1.canUseEventBridge)()) {
        const batch = (0, startRumBatch_1.startRumBatch)(configuration, lifeCycle, reportError, pageMayExitObservable, session.expireObservable, createEncoder);
        cleanupTasks.push(() => batch.stop());
        (0, startCustomerDataTelemetry_1.startCustomerDataTelemetry)(telemetry, lifeCycle, batch.flushController.flushObservable);
    }
    else {
        (0, startRumEventBridge_1.startRumEventBridge)(lifeCycle);
    }
    (0, trackingConsentContext_1.startTrackingConsentContext)(hooks, trackingConsentState);
    const { stop: stopInitialViewMetricsTelemetry } = (0, startInitialViewMetricsTelemetry_1.startInitialViewMetricsTelemetry)(lifeCycle, telemetry);
    cleanupTasks.push(stopInitialViewMetricsTelemetry);
    const { stop: stopRumEventCollection, ...startRumEventCollectionResult } = startRumEventCollection(lifeCycle, hooks, configuration, session, recorderApi, initialViewOptions, customVitalsState, bufferedDataObservable, sdkName, reportError);
    cleanupTasks.push(stopRumEventCollection);
    bufferedDataObservable.unbuffer();
    // Add Clean-up tasks for Profiler API.
    cleanupTasks.push(() => profilerApi.stop());
    return {
        ...startRumEventCollectionResult,
        lifeCycle,
        session,
        stopSession: () => session.expire(),
        telemetry,
        stop: () => {
            cleanupTasks.forEach((task) => task());
        },
        hooks,
    };
}
function startRumEventCollection(lifeCycle, hooks, configuration, session, recorderApi, initialViewOptions, customVitalsState, bufferedDataObservable, sdkName, reportError) {
    const cleanupTasks = [];
    const domMutationObservable = (0, domMutationObservable_1.createDOMMutationObservable)();
    const locationChangeObservable = (0, locationChangeObservable_1.createLocationChangeObservable)(configuration, location);
    const { observable: windowOpenObservable, stop: stopWindowOpen } = (0, windowOpenObservable_1.createWindowOpenObservable)();
    cleanupTasks.push(stopWindowOpen);
    (0, defaultContext_1.startDefaultContext)(hooks, configuration, sdkName);
    const pageStateHistory = (0, pageStateHistory_1.startPageStateHistory)(hooks, configuration);
    cleanupTasks.push(() => pageStateHistory.stop());
    const viewHistory = (0, viewHistory_1.startViewHistory)(lifeCycle);
    cleanupTasks.push(() => viewHistory.stop());
    const urlContexts = (0, urlContexts_1.startUrlContexts)(lifeCycle, hooks, locationChangeObservable, location);
    cleanupTasks.push(() => urlContexts.stop());
    const featureFlagContexts = (0, featureFlagContext_1.startFeatureFlagContexts)(lifeCycle, hooks, configuration);
    (0, sessionContext_1.startSessionContext)(hooks, session, recorderApi, viewHistory);
    (0, connectivityContext_1.startConnectivityContext)(hooks);
    const globalContext = (0, browser_core_1.startGlobalContext)(hooks, configuration, 'rum', true);
    const userContext = (0, browser_core_1.startUserContext)(hooks, configuration, session, 'rum');
    const accountContext = (0, browser_core_1.startAccountContext)(hooks, configuration, 'rum');
    const actionCollection = (0, actionCollection_1.startActionCollection)(lifeCycle, hooks, domMutationObservable, windowOpenObservable, configuration);
    cleanupTasks.push(actionCollection.stop);
    const eventCollection = (0, eventCollection_1.startEventCollection)(lifeCycle);
    const displayContext = (0, displayContext_1.startDisplayContext)(hooks, configuration);
    cleanupTasks.push(displayContext.stop);
    const ciVisibilityContext = (0, ciVisibilityContext_1.startCiVisibilityContext)(configuration, hooks);
    cleanupTasks.push(ciVisibilityContext.stop);
    (0, syntheticsContext_1.startSyntheticsContext)(hooks);
    (0, assembly_1.startRumAssembly)(configuration, lifeCycle, hooks, reportError);
    const { addTiming, startView, setViewName, setViewContext, setViewContextProperty, getViewContext, stop: stopViewCollection, } = (0, viewCollection_1.startViewCollection)(lifeCycle, hooks, configuration, location, domMutationObservable, windowOpenObservable, locationChangeObservable, recorderApi, viewHistory, initialViewOptions);
    cleanupTasks.push(stopViewCollection);
    const { stop: stopResourceCollection } = (0, resourceCollection_1.startResourceCollection)(lifeCycle, configuration, pageStateHistory);
    cleanupTasks.push(stopResourceCollection);
    const { stop: stopLongTaskCollection, longTaskContexts } = (0, longTaskCollection_1.startLongTaskCollection)(lifeCycle, configuration);
    cleanupTasks.push(stopLongTaskCollection);
    const { addError } = (0, errorCollection_1.startErrorCollection)(lifeCycle, configuration, bufferedDataObservable);
    (0, requestCollection_1.startRequestCollection)(lifeCycle, configuration, session, userContext, accountContext);
    const vitalCollection = (0, vitalCollection_1.startVitalCollection)(lifeCycle, pageStateHistory, customVitalsState);
    const internalContext = (0, internalContext_1.startInternalContext)(configuration.applicationId, session, viewHistory, actionCollection.actionContexts, urlContexts);
    return {
        addAction: actionCollection.addAction,
        addEvent: eventCollection.addEvent,
        addError,
        addTiming,
        addFeatureFlagEvaluation: featureFlagContexts.addFeatureFlagEvaluation,
        startView,
        setViewContext,
        setViewContextProperty,
        getViewContext,
        setViewName,
        viewHistory,
        getInternalContext: internalContext.get,
        startDurationVital: vitalCollection.startDurationVital,
        stopDurationVital: vitalCollection.stopDurationVital,
        addDurationVital: vitalCollection.addDurationVital,
        addOperationStepVital: vitalCollection.addOperationStepVital,
        globalContext,
        userContext,
        accountContext,
        longTaskContexts,
        stop: () => cleanupTasks.forEach((task) => task()),
    };
}
//# sourceMappingURL=startRum.js.map