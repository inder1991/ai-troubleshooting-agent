import { display, buildEndpointHost, mapValues, getCookie, addTelemetryMetrics, isIndexableObject, } from '@datadog/browser-core';
import { parseJsonPath } from './jsonPathParser';
const REMOTE_CONFIGURATION_VERSION = 'v1';
const SUPPORTED_FIELDS = [
    'applicationId',
    'service',
    'env',
    'version',
    'sessionSampleRate',
    'sessionReplaySampleRate',
    'defaultPrivacyLevel',
    'enablePrivacyForActionName',
    'traceSampleRate',
    'trackSessionAcrossSubdomains',
    'allowedTracingUrls',
    'allowedTrackingOrigins',
];
export async function fetchAndApplyRemoteConfiguration(initConfiguration, supportedContextManagers) {
    let rumInitConfiguration;
    const metrics = initMetrics();
    const fetchResult = await fetchRemoteConfiguration(initConfiguration);
    if (!fetchResult.ok) {
        metrics.increment('fetch', 'failure');
        display.error(fetchResult.error);
    }
    else {
        metrics.increment('fetch', 'success');
        rumInitConfiguration = applyRemoteConfiguration(initConfiguration, fetchResult.value, supportedContextManagers, metrics);
    }
    // monitor-until: forever
    addTelemetryMetrics("remote configuration metrics" /* TelemetryMetrics.REMOTE_CONFIGURATION_METRIC_NAME */, { metrics: metrics.get() });
    return rumInitConfiguration;
}
export function applyRemoteConfiguration(initConfiguration, rumRemoteConfiguration, supportedContextManagers, metrics) {
    // intents:
    // - explicitly set each supported field to limit risk in case an attacker can create configurations
    // - check the existence in the remote config to avoid clearing a provided init field
    const appliedConfiguration = { ...initConfiguration };
    SUPPORTED_FIELDS.forEach((option) => {
        if (option in rumRemoteConfiguration) {
            appliedConfiguration[option] = resolveConfigurationProperty(rumRemoteConfiguration[option]);
        }
    });
    Object.keys(supportedContextManagers).forEach((context) => {
        if (rumRemoteConfiguration[context] !== undefined) {
            resolveContextProperty(supportedContextManagers[context], rumRemoteConfiguration[context]);
        }
    });
    return appliedConfiguration;
    // share context to access metrics
    function resolveConfigurationProperty(property) {
        if (Array.isArray(property)) {
            return property.map(resolveConfigurationProperty);
        }
        if (isIndexableObject(property)) {
            if (isSerializedOption(property)) {
                const type = property.rcSerializedType;
                switch (type) {
                    case 'string':
                        return property.value;
                    case 'regex':
                        return resolveRegex(property.value);
                    case 'dynamic':
                        return resolveDynamicOption(property);
                    default:
                        display.error(`Unsupported remote configuration: "rcSerializedType": "${type}"`);
                        return;
                }
            }
            return mapValues(property, resolveConfigurationProperty);
        }
        return property;
    }
    function resolveContextProperty(contextManager, contextItems) {
        contextItems.forEach(({ key, value }) => {
            contextManager.setContextProperty(key, resolveConfigurationProperty(value));
        });
    }
    function resolveDynamicOption(property) {
        const strategy = property.strategy;
        let resolvedValue;
        switch (strategy) {
            case 'cookie':
                resolvedValue = resolveCookieValue(property);
                break;
            case 'dom':
                resolvedValue = resolveDomValue(property);
                break;
            case 'js':
                resolvedValue = resolveJsValue(property);
                break;
            default:
                display.error(`Unsupported remote configuration: "strategy": "${strategy}"`);
                return;
        }
        const extractor = property.extractor;
        if (extractor !== undefined && typeof resolvedValue === 'string') {
            return extractValue(extractor, resolvedValue);
        }
        return resolvedValue;
    }
    function resolveCookieValue({ name }) {
        const value = getCookie(name);
        metrics.increment('cookie', value !== undefined ? 'success' : 'missing');
        return value;
    }
    function resolveDomValue({ selector, attribute }) {
        let element;
        try {
            element = document.querySelector(selector);
        }
        catch (_a) {
            display.error(`Invalid selector in the remote configuration: '${selector}'`);
            metrics.increment('dom', 'failure');
            return;
        }
        if (!element) {
            metrics.increment('dom', 'missing');
            return;
        }
        if (isForbidden(element, attribute)) {
            display.error(`Forbidden element selected by the remote configuration: '${selector}'`);
            metrics.increment('dom', 'failure');
            return;
        }
        const domValue = attribute !== undefined ? element.getAttribute(attribute) : element.textContent;
        if (domValue === null) {
            metrics.increment('dom', 'missing');
            return;
        }
        metrics.increment('dom', 'success');
        return domValue;
    }
    function isForbidden(element, attribute) {
        return element.getAttribute('type') === 'password' && attribute === 'value';
    }
    function resolveJsValue({ path }) {
        let current = window;
        const pathParts = parseJsonPath(path);
        if (pathParts.length === 0) {
            display.error(`Invalid JSON path in the remote configuration: '${path}'`);
            metrics.increment('js', 'failure');
            return;
        }
        for (const pathPart of pathParts) {
            if (!(pathPart in current)) {
                metrics.increment('js', 'missing');
                return;
            }
            try {
                current = current[pathPart];
            }
            catch (e) {
                display.error(`Error accessing: '${path}'`, e);
                metrics.increment('js', 'failure');
                return;
            }
        }
        metrics.increment('js', 'success');
        return current;
    }
}
export function initMetrics() {
    const metrics = { fetch: {} };
    return {
        get: () => metrics,
        increment: (metricName, type) => {
            if (!metrics[metricName]) {
                metrics[metricName] = {};
            }
            if (!metrics[metricName][type]) {
                metrics[metricName][type] = 0;
            }
            metrics[metricName][type] = metrics[metricName][type] + 1;
        },
    };
}
function isSerializedOption(value) {
    return 'rcSerializedType' in value;
}
function resolveRegex(pattern) {
    try {
        return new RegExp(pattern);
    }
    catch (_a) {
        display.error(`Invalid regex in the remote configuration: '${pattern}'`);
    }
}
function extractValue(extractor, candidate) {
    const resolvedExtractor = resolveRegex(extractor.value);
    if (resolvedExtractor === undefined) {
        return;
    }
    const regexResult = resolvedExtractor.exec(candidate);
    if (regexResult === null) {
        return;
    }
    const [match, capture] = regexResult;
    return capture ? capture : match;
}
export async function fetchRemoteConfiguration(configuration) {
    let response;
    try {
        response = await fetch(buildEndpoint(configuration));
    }
    catch (_a) {
        response = undefined;
    }
    if (!response || !response.ok) {
        return {
            ok: false,
            error: new Error('Error fetching the remote configuration.'),
        };
    }
    const remoteConfiguration = await response.json();
    if (remoteConfiguration.rum) {
        return {
            ok: true,
            value: remoteConfiguration.rum,
        };
    }
    return {
        ok: false,
        error: new Error('No remote configuration for RUM.'),
    };
}
export function buildEndpoint(configuration) {
    if (configuration.remoteConfigurationProxy) {
        return configuration.remoteConfigurationProxy;
    }
    return `https://sdk-configuration.${buildEndpointHost('rum', configuration)}/${REMOTE_CONFIGURATION_VERSION}/${encodeURIComponent(configuration.remoteConfigurationId)}.json`;
}
//# sourceMappingURL=remoteConfiguration.js.map