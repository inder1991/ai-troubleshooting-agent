import { ContextManagerMethod, addTelemetryUsage, deepClone, makePublicApi, monitor, clocksNow, callMonitored, createHandlingStack, sanitize, createIdentityEncoder, displayAlreadyInitializedError, createTrackingConsentState, timeStampToClocks, CustomerContextKey, defineContextMethod, startBufferingData, } from '@datadog/browser-core';
import { ActionType, VitalType } from '../rawRumEvent.types';
import { createCustomVitalsState } from '../domain/vital/vitalCollection';
import { callPluginsMethod } from '../domain/plugins';
import { createPreStartStrategy } from './preStartRum';
export function makeRumPublicApi(startRumImpl, recorderApi, profilerApi, options = {}) {
    const trackingConsentState = createTrackingConsentState();
    const customVitalsState = createCustomVitalsState();
    const bufferedDataObservable = startBufferingData().observable;
    let strategy = createPreStartStrategy(options, trackingConsentState, customVitalsState, (configuration, deflateWorker, initialViewOptions) => {
        const createEncoder = deflateWorker && options.createDeflateEncoder
            ? (streamId) => options.createDeflateEncoder(configuration, deflateWorker, streamId)
            : createIdentityEncoder;
        const startRumResult = startRumImpl(configuration, recorderApi, profilerApi, initialViewOptions, createEncoder, trackingConsentState, customVitalsState, bufferedDataObservable, options.sdkName);
        recorderApi.onRumStart(startRumResult.lifeCycle, configuration, startRumResult.session, startRumResult.viewHistory, deflateWorker, startRumResult.telemetry);
        profilerApi.onRumStart(startRumResult.lifeCycle, startRumResult.hooks, configuration, startRumResult.session, startRumResult.viewHistory, startRumResult.longTaskContexts, createEncoder);
        strategy = createPostStartStrategy(strategy, startRumResult);
        callPluginsMethod(configuration.plugins, 'onRumStart', {
            strategy, // TODO: remove this in the next major release
            addEvent: startRumResult.addEvent,
        });
        return startRumResult;
    });
    const getStrategy = () => strategy;
    const startView = monitor((options) => {
        const sanitizedOptions = typeof options === 'object' ? options : { name: options };
        strategy.startView(sanitizedOptions);
        addTelemetryUsage({ feature: 'start-view' });
    });
    const rumPublicApi = makePublicApi({
        init: (initConfiguration) => {
            const errorStack = new Error().stack;
            callMonitored(() => strategy.init(initConfiguration, rumPublicApi, errorStack));
        },
        setTrackingConsent: monitor((trackingConsent) => {
            trackingConsentState.update(trackingConsent);
            addTelemetryUsage({ feature: 'set-tracking-consent', tracking_consent: trackingConsent });
        }),
        setViewName: monitor((name) => {
            strategy.setViewName(name);
            addTelemetryUsage({ feature: 'set-view-name' });
        }),
        setViewContext: monitor((context) => {
            strategy.setViewContext(context);
            addTelemetryUsage({ feature: 'set-view-context' });
        }),
        setViewContextProperty: monitor((key, value) => {
            strategy.setViewContextProperty(key, value);
            addTelemetryUsage({ feature: 'set-view-context-property' });
        }),
        getViewContext: monitor(() => {
            addTelemetryUsage({ feature: 'set-view-context-property' });
            return strategy.getViewContext();
        }),
        getInternalContext: monitor((startTime) => strategy.getInternalContext(startTime)),
        getInitConfiguration: monitor(() => deepClone(strategy.initConfiguration)),
        addAction: (name, context) => {
            const handlingStack = createHandlingStack('action');
            callMonitored(() => {
                strategy.addAction({
                    name: sanitize(name),
                    context: sanitize(context),
                    startClocks: clocksNow(),
                    type: ActionType.CUSTOM,
                    handlingStack,
                });
                addTelemetryUsage({ feature: 'add-action' });
            });
        },
        addError: (error, context) => {
            const handlingStack = createHandlingStack('error');
            callMonitored(() => {
                strategy.addError({
                    error, // Do not sanitize error here, it is needed unserialized by computeRawError()
                    handlingStack,
                    context: sanitize(context),
                    startClocks: clocksNow(),
                });
                addTelemetryUsage({ feature: 'add-error' });
            });
        },
        addTiming: monitor((name, time) => {
            // TODO: next major decide to drop relative time support or update its behaviour
            strategy.addTiming(sanitize(name), time);
        }),
        setGlobalContext: defineContextMethod(getStrategy, CustomerContextKey.globalContext, ContextManagerMethod.setContext, 'set-global-context'),
        getGlobalContext: defineContextMethod(getStrategy, CustomerContextKey.globalContext, ContextManagerMethod.getContext, 'get-global-context'),
        setGlobalContextProperty: defineContextMethod(getStrategy, CustomerContextKey.globalContext, ContextManagerMethod.setContextProperty, 'set-global-context-property'),
        removeGlobalContextProperty: defineContextMethod(getStrategy, CustomerContextKey.globalContext, ContextManagerMethod.removeContextProperty, 'remove-global-context-property'),
        clearGlobalContext: defineContextMethod(getStrategy, CustomerContextKey.globalContext, ContextManagerMethod.clearContext, 'clear-global-context'),
        setUser: defineContextMethod(getStrategy, CustomerContextKey.userContext, ContextManagerMethod.setContext, 'set-user'),
        getUser: defineContextMethod(getStrategy, CustomerContextKey.userContext, ContextManagerMethod.getContext, 'get-user'),
        setUserProperty: defineContextMethod(getStrategy, CustomerContextKey.userContext, ContextManagerMethod.setContextProperty, 'set-user-property'),
        removeUserProperty: defineContextMethod(getStrategy, CustomerContextKey.userContext, ContextManagerMethod.removeContextProperty, 'remove-user-property'),
        clearUser: defineContextMethod(getStrategy, CustomerContextKey.userContext, ContextManagerMethod.clearContext, 'clear-user'),
        setAccount: defineContextMethod(getStrategy, CustomerContextKey.accountContext, ContextManagerMethod.setContext, 'set-account'),
        getAccount: defineContextMethod(getStrategy, CustomerContextKey.accountContext, ContextManagerMethod.getContext, 'get-account'),
        setAccountProperty: defineContextMethod(getStrategy, CustomerContextKey.accountContext, ContextManagerMethod.setContextProperty, 'set-account-property'),
        removeAccountProperty: defineContextMethod(getStrategy, CustomerContextKey.accountContext, ContextManagerMethod.removeContextProperty, 'remove-account-property'),
        clearAccount: defineContextMethod(getStrategy, CustomerContextKey.accountContext, ContextManagerMethod.clearContext, 'clear-account'),
        startView,
        stopSession: monitor(() => {
            strategy.stopSession();
            addTelemetryUsage({ feature: 'stop-session' });
        }),
        addFeatureFlagEvaluation: monitor((key, value) => {
            strategy.addFeatureFlagEvaluation(sanitize(key), sanitize(value));
            addTelemetryUsage({ feature: 'add-feature-flag-evaluation' });
        }),
        getSessionReplayLink: monitor(() => recorderApi.getSessionReplayLink()),
        startSessionReplayRecording: monitor((options) => {
            recorderApi.start(options);
            addTelemetryUsage({ feature: 'start-session-replay-recording', force: options && options.force });
        }),
        stopSessionReplayRecording: monitor(() => recorderApi.stop()),
        addDurationVital: monitor((name, options) => {
            addTelemetryUsage({ feature: 'add-duration-vital' });
            strategy.addDurationVital({
                name: sanitize(name),
                type: VitalType.DURATION,
                startClocks: timeStampToClocks(options.startTime),
                duration: options.duration,
                context: sanitize(options && options.context),
                description: sanitize(options && options.description),
            });
        }),
        startDurationVital: monitor((name, options) => {
            addTelemetryUsage({ feature: 'start-duration-vital' });
            return strategy.startDurationVital(sanitize(name), {
                context: sanitize(options && options.context),
                description: sanitize(options && options.description),
            });
        }),
        stopDurationVital: monitor((nameOrRef, options) => {
            addTelemetryUsage({ feature: 'stop-duration-vital' });
            strategy.stopDurationVital(typeof nameOrRef === 'string' ? sanitize(nameOrRef) : nameOrRef, {
                context: sanitize(options && options.context),
                description: sanitize(options && options.description),
            });
        }),
        startFeatureOperation: monitor((name, options) => {
            addTelemetryUsage({ feature: 'add-operation-step-vital', action_type: 'start' });
            strategy.addOperationStepVital(name, 'start', options);
        }),
        succeedFeatureOperation: monitor((name, options) => {
            addTelemetryUsage({ feature: 'add-operation-step-vital', action_type: 'succeed' });
            strategy.addOperationStepVital(name, 'end', options);
        }),
        failFeatureOperation: monitor((name, failureReason, options) => {
            addTelemetryUsage({ feature: 'add-operation-step-vital', action_type: 'fail' });
            strategy.addOperationStepVital(name, 'end', options, failureReason);
        }),
    });
    return rumPublicApi;
}
function createPostStartStrategy(preStartStrategy, startRumResult) {
    return {
        init: (initConfiguration) => {
            displayAlreadyInitializedError('DD_RUM', initConfiguration);
        },
        initConfiguration: preStartStrategy.initConfiguration,
        ...startRumResult,
    };
}
//# sourceMappingURL=rumPublicApi.js.map