import {
  addEventListener,
  buildTags,
  clearTimeout,
  clocksNow,
  clocksOrigin,
  createFormDataTransport,
  currentDrift,
  display,
  elapsed,
  getGlobalObject,
  monitorError,
  setTimeout
} from "./chunk-7Z3K2D2T.js";
import "./chunk-FDBJFBLO.js";

// node_modules/@datadog/browser-rum/esm/domain/profiling/utils/getNumberOfSamples.js
function getNumberOfSamples(samples) {
  let numberOfSamples = 0;
  for (const sample of samples) {
    if (sample.stackId !== void 0) {
      numberOfSamples++;
    }
  }
  return numberOfSamples;
}

// node_modules/@datadog/browser-rum/esm/domain/profiling/utils/getDefaultViewName.js
var PATH_MIXED_ALPHANUMERICS = /\/(?![vV]\d{1,2}\/)([^/\d?]*\d+[^/?]*)/g;
function getDefaultViewName(viewPathUrl) {
  if (!viewPathUrl) {
    return "/";
  }
  return viewPathUrl.replace(PATH_MIXED_ALPHANUMERICS, "/?");
}

// node_modules/@datadog/browser-rum/esm/domain/profiling/utils/getCustomOrDefaultViewName.js
var getCustomOrDefaultViewName = (customViewName, viewPathUrl) => customViewName || getDefaultViewName(viewPathUrl);

// node_modules/@datadog/browser-rum/esm/domain/profiling/transport/buildProfileEventAttributes.js
function buildProfileEventAttributes(profilerTrace, applicationId, sessionId) {
  const attributes = {
    application: {
      id: applicationId
    }
  };
  if (sessionId) {
    attributes.session = {
      id: sessionId
    };
  }
  const { ids, names } = extractViewIdsAndNames(profilerTrace.views);
  if (ids.length) {
    attributes.view = {
      id: ids,
      name: names
    };
  }
  const longTaskIds = profilerTrace.longTasks.map((longTask) => longTask.id).filter((id) => id !== void 0);
  if (longTaskIds.length) {
    attributes.long_task = { id: longTaskIds };
  }
  return attributes;
}
function extractViewIdsAndNames(views) {
  const result = { ids: [], names: [] };
  for (const view of views) {
    result.ids.push(view.viewId);
    if (view.viewName) {
      result.names.push(view.viewName);
    }
  }
  result.names = Array.from(new Set(result.names));
  return result;
}

// node_modules/@datadog/browser-rum/esm/domain/profiling/transport/assembly.js
function assembleProfilingPayload(profilerTrace, configuration, sessionId) {
  const event = buildProfileEvent(profilerTrace, configuration, sessionId);
  return {
    event,
    "wall-time.json": profilerTrace
  };
}
function buildProfileEvent(profilerTrace, configuration, sessionId) {
  const tags = buildTags(configuration);
  const profileAttributes = buildProfileEventAttributes(profilerTrace, configuration.applicationId, sessionId);
  const profileEventTags = buildProfileEventTags(tags);
  const profileEvent = {
    ...profileAttributes,
    attachments: ["wall-time.json"],
    start: new Date(profilerTrace.startClocks.timeStamp).toISOString(),
    end: new Date(profilerTrace.endClocks.timeStamp).toISOString(),
    family: "chrome",
    runtime: "chrome",
    format: "json",
    version: 4,
    // Ingestion event version (not the version application tag)
    tags_profiler: profileEventTags.join(","),
    _dd: {
      clock_drift: currentDrift()
    }
  };
  return profileEvent;
}
function buildProfileEventTags(tags) {
  const profileEventTags = tags.concat(["language:javascript", "runtime:chrome", "family:chrome", "host:browser"]);
  return profileEventTags;
}

// node_modules/@datadog/browser-rum/esm/domain/profiling/profiler.js
var DEFAULT_RUM_PROFILER_CONFIGURATION = {
  sampleIntervalMs: 10,
  // Sample stack trace every 10ms
  collectIntervalMs: 6e4,
  // Collect data every minute
  minProfileDurationMs: 5e3,
  // Require at least 5 seconds of profile data to reduce noise and cost
  minNumberOfSamples: 50
  // Require at least 50 samples (~500 ms) to report a profile to reduce noise and cost
};
function createRumProfiler(configuration, lifeCycle, session, profilingContextManager, longTaskContexts, createEncoder, viewHistory, profilerConfiguration = DEFAULT_RUM_PROFILER_CONFIGURATION) {
  const transport = createFormDataTransport(
    configuration,
    lifeCycle,
    createEncoder,
    6
    /* DeflateEncoderStreamId.PROFILING */
  );
  let lastViewEntry;
  const globalCleanupTasks = [];
  let instance = { state: "stopped", stateReason: "initializing" };
  lifeCycle.subscribe(9, () => {
    stopProfiling("session-expired").catch(monitorError);
  });
  lifeCycle.subscribe(10, () => {
    if (instance.state === "stopped" && instance.stateReason === "session-expired") {
      start();
    }
  });
  function start() {
    if (instance.state === "running") {
      return;
    }
    const viewEntry = viewHistory.findView();
    lastViewEntry = viewEntry ? {
      startClocks: viewEntry.startClocks,
      viewId: viewEntry.id,
      viewName: getCustomOrDefaultViewName(viewEntry.name, document.location.pathname)
    } : void 0;
    globalCleanupTasks.push(addEventListener(configuration, window, "visibilitychange", handleVisibilityChange).stop, addEventListener(configuration, window, "beforeunload", handleBeforeUnload).stop);
    startNextProfilerInstance();
  }
  async function stop() {
    await stopProfiling("stopped-by-user");
  }
  async function stopProfiling(reason) {
    await stopProfilerInstance(reason);
    globalCleanupTasks.forEach((task) => task());
    profilingContextManager.set({ status: "stopped", error_reason: void 0 });
  }
  function addEventListeners(existingInstance) {
    if (existingInstance.state === "running") {
      return {
        cleanupTasks: existingInstance.cleanupTasks
      };
    }
    const cleanupTasks = [];
    const viewUpdatedSubscription = lifeCycle.subscribe(2, (view) => {
      const viewEntry = {
        viewId: view.id,
        // Note: `viewName` is only filled when users use manual view creation via `startView` method.
        viewName: getCustomOrDefaultViewName(view.name, document.location.pathname),
        startClocks: view.startClocks
      };
      collectViewEntry(viewEntry);
      lastViewEntry = viewEntry;
    });
    cleanupTasks.push(viewUpdatedSubscription.unsubscribe);
    return {
      cleanupTasks
    };
  }
  function startNextProfilerInstance() {
    const globalThisProfiler = getGlobalObject().Profiler;
    if (!globalThisProfiler) {
      profilingContextManager.set({ status: "error", error_reason: "not-supported-by-browser" });
      throw new Error("RUM Profiler is not supported in this browser.");
    }
    collectProfilerInstance(instance).catch(monitorError);
    const { cleanupTasks } = addEventListeners(instance);
    let profiler;
    try {
      profiler = new globalThisProfiler({
        sampleInterval: profilerConfiguration.sampleIntervalMs,
        // Keep buffer size at 1.5 times of minimum required to collect data for a profiling instance
        maxBufferSize: Math.round(profilerConfiguration.collectIntervalMs * 1.5 / profilerConfiguration.sampleIntervalMs)
      });
    } catch (e) {
      if (e instanceof Error && e.message.includes("disabled by Document Policy")) {
        display.warn("[DD_RUM] Profiler startup failed. Ensure your server includes the `Document-Policy: js-profiling` response header when serving HTML pages.", e);
        profilingContextManager.set({ status: "error", error_reason: "missing-document-policy-header" });
      } else {
        profilingContextManager.set({ status: "error", error_reason: "unexpected-exception" });
      }
      return;
    }
    profilingContextManager.set({ status: "running", error_reason: void 0 });
    instance = {
      state: "running",
      startClocks: clocksNow(),
      profiler,
      timeoutId: setTimeout(startNextProfilerInstance, profilerConfiguration.collectIntervalMs),
      views: [],
      cleanupTasks,
      longTasks: []
    };
    collectViewEntry(lastViewEntry);
    profiler.addEventListener("samplebufferfull", handleSampleBufferFull);
  }
  async function collectProfilerInstance(lastInstance) {
    if (lastInstance.state !== "running") {
      return;
    }
    clearTimeout(lastInstance.timeoutId);
    lastInstance.profiler.removeEventListener("samplebufferfull", handleSampleBufferFull);
    const { startClocks, views } = lastInstance;
    await lastInstance.profiler.stop().then((trace) => {
      const endClocks = clocksNow();
      const duration = elapsed(startClocks.timeStamp, endClocks.timeStamp);
      const longTasks = longTaskContexts.findLongTasks(startClocks.relative, duration);
      const isBelowDurationThreshold = duration < profilerConfiguration.minProfileDurationMs;
      const isBelowSampleThreshold = getNumberOfSamples(trace.samples) < profilerConfiguration.minNumberOfSamples;
      if (longTasks.length === 0 && (isBelowDurationThreshold || isBelowSampleThreshold)) {
        return;
      }
      handleProfilerTrace(
        // Enrich trace with time and instance data
        Object.assign(trace, {
          startClocks,
          endClocks,
          clocksOrigin: clocksOrigin(),
          longTasks,
          views,
          sampleInterval: profilerConfiguration.sampleIntervalMs
        })
      );
    }).catch(monitorError);
  }
  async function stopProfilerInstance(stateReason) {
    if (instance.state !== "running") {
      return;
    }
    await onPauseOrStopProfilerInstance();
    instance = { state: "stopped", stateReason };
  }
  async function pauseProfilerInstance() {
    if (instance.state !== "running") {
      return;
    }
    await onPauseOrStopProfilerInstance();
    instance = { state: "paused" };
  }
  async function onPauseOrStopProfilerInstance() {
    if (instance.state !== "running") {
      return;
    }
    instance.cleanupTasks.forEach((cleanupTask) => cleanupTask());
    await collectProfilerInstance(instance);
  }
  function collectViewEntry(viewEntry) {
    if (instance.state !== "running" || !viewEntry) {
      return;
    }
    instance.views.push(viewEntry);
  }
  function handleProfilerTrace(trace) {
    var _a;
    const sessionId = (_a = session.findTrackedSession()) === null || _a === void 0 ? void 0 : _a.id;
    const payload = assembleProfilingPayload(trace, configuration, sessionId);
    void transport.send(payload);
  }
  function handleSampleBufferFull() {
    startNextProfilerInstance();
  }
  function handleVisibilityChange() {
    if (document.visibilityState === "hidden" && instance.state === "running") {
      pauseProfilerInstance().catch(monitorError);
    } else if (document.visibilityState === "visible" && instance.state === "paused") {
      startNextProfilerInstance();
    }
  }
  function handleBeforeUnload() {
    startNextProfilerInstance();
  }
  function isStopped() {
    return instance.state === "stopped";
  }
  function isRunning() {
    return instance.state === "running";
  }
  function isPaused() {
    return instance.state === "paused";
  }
  return { start, stop, isStopped, isRunning, isPaused };
}
export {
  DEFAULT_RUM_PROFILER_CONFIGURATION,
  createRumProfiler
};
//# sourceMappingURL=profiler-4ZOFRKTQ.js.map
