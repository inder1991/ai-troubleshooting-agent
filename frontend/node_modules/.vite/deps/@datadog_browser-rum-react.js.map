{
  "version": 3,
  "sources": ["../../@datadog/browser-rum-react/src/domain/error/errorBoundary.ts", "../../@datadog/browser-rum-react/src/domain/reactPlugin.ts", "../../@datadog/browser-rum-react/src/domain/error/addReactError.ts", "../../@datadog/browser-rum-react/src/domain/performance/reactComponentTracker.tsx", "../../@datadog/browser-rum-react/src/domain/performance/timer.ts", "../../@datadog/browser-rum-react/src/domain/performance/addDurationVital.ts"],
  "sourcesContent": ["import React from 'react'\nimport type { ErrorInfo } from 'react'\nimport { addReactError } from './addReactError'\n\nexport interface ErrorBoundaryProps {\n  fallback: ErrorBoundaryFallback\n  children: React.ReactNode\n}\n\nexport type ErrorBoundaryFallback = React.ComponentType<{ error: Error; resetError: () => void }>\n\nexport type State =\n  | {\n      didCatch: false\n      error: null\n    }\n  | {\n      didCatch: true\n      error: Error\n    }\n\nconst INITIAL_STATE: State = { didCatch: false, error: null }\n\n/**\n * ErrorBoundary component to report React errors to Datadog.\n *\n * For more advanced error handling, you can use the {@link addReactError} function.\n *\n * @category Error\n * @example\n * ```ts\n * import { ErrorBoundary } from '@datadog/browser-rum-react'\n *\n * <ErrorBoundary fallback={() => null}>\n *   <Component />\n * </ErrorBoundary>\n * ```\n */\n// eslint-disable-next-line no-restricted-syntax\nexport class ErrorBoundary extends React.Component<ErrorBoundaryProps, State> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n    this.state = INITIAL_STATE\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    return { didCatch: true, error }\n  }\n\n  resetError = () => {\n    this.setState(INITIAL_STATE)\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    addReactError(error, errorInfo)\n  }\n\n  render() {\n    if (this.state.didCatch) {\n      return React.createElement(this.props.fallback, {\n        error: this.state.error,\n        resetError: this.resetError,\n      })\n    }\n\n    return this.props.children\n  }\n}\n", "import type { RumPlugin, RumPublicApi, StartRumResult } from '@datadog/browser-rum-core'\n\nlet globalPublicApi: RumPublicApi | undefined\nlet globalConfiguration: ReactPluginConfiguration | undefined\nlet globalAddEvent: StartRumResult['addEvent'] | undefined\ntype InitSubscriber = (configuration: ReactPluginConfiguration, rumPublicApi: RumPublicApi) => void\ntype StartSubscriber = (addEvent: StartRumResult['addEvent']) => void\n\nconst onRumInitSubscribers: InitSubscriber[] = []\nconst onRumStartSubscribers: StartSubscriber[] = []\n\n/**\n * React plugin configuration.\n *\n * @category Main\n */\nexport interface ReactPluginConfiguration {\n  /**\n   * Enable react-router integration. Make sure to use functions from\n   * {@link @datadog/browser-rum-react/react-router-v6! | @datadog/browser-rum-react/react-router-v6} or\n   * {@link @datadog/browser-rum-react/react-router-v7! | @datadog/browser-rum-react/react-router-v7}\n   * to create the router.\n   * ```\n   */\n  router?: boolean\n}\n\n/**\n * React plugin type.\n *\n * The plugins API is unstable and experimental, and may change without notice. Please don't use this type directly.\n *\n * @internal\n */\nexport type ReactPlugin = Required<RumPlugin>\n\n/**\n * React plugin constructor.\n *\n * @category Main\n * @example\n * ```ts\n * import { datadogRum } from '@datadog/browser-rum'\n * import { reactPlugin } from '@datadog/browser-rum-react'\n *\n * datadogRum.init({\n *   applicationId: '<DATADOG_APPLICATION_ID>',\n *   clientToken: '<DATADOG_CLIENT_TOKEN>',\n *   site: '<DATADOG_SITE>',\n *   plugins: [reactPlugin()],\n *   // ...\n * })\n * ```\n */\nexport function reactPlugin(configuration: ReactPluginConfiguration = {}): ReactPlugin {\n  return {\n    name: 'react',\n    onInit({ publicApi, initConfiguration }) {\n      globalPublicApi = publicApi\n      globalConfiguration = configuration\n      for (const subscriber of onRumInitSubscribers) {\n        subscriber(globalConfiguration, globalPublicApi)\n      }\n      if (configuration.router) {\n        initConfiguration.trackViewsManually = true\n      }\n    },\n    onRumStart({ addEvent }) {\n      globalAddEvent = addEvent\n      for (const subscriber of onRumStartSubscribers) {\n        if (addEvent) {\n          subscriber(addEvent)\n        }\n      }\n    },\n    getConfigurationTelemetry() {\n      return { router: !!configuration.router }\n    },\n  } satisfies RumPlugin\n}\n\nexport function onRumInit(callback: InitSubscriber) {\n  if (globalConfiguration && globalPublicApi) {\n    callback(globalConfiguration, globalPublicApi)\n  } else {\n    onRumInitSubscribers.push(callback)\n  }\n}\n\nexport function onRumStart(callback: StartSubscriber) {\n  if (globalAddEvent) {\n    callback(globalAddEvent)\n  } else {\n    onRumStartSubscribers.push(callback)\n  }\n}\n\nexport function resetReactPlugin() {\n  globalPublicApi = undefined\n  globalConfiguration = undefined\n  globalAddEvent = undefined\n  onRumInitSubscribers.length = 0\n  onRumStartSubscribers.length = 0\n}\n", "import type { ErrorInfo } from 'react'\nimport {\n  callMonitored,\n  clocksNow,\n  computeRawError,\n  createHandlingStack,\n  ErrorHandling,\n  ErrorSource,\n  generateUUID,\n  NonErrorPrefix,\n} from '@datadog/browser-core'\nimport { RumEventType } from '@datadog/browser-rum-core'\nimport { onRumStart } from '../reactPlugin'\n\n/**\n * Add a React error to the RUM session.\n *\n * @category Error\n * @example\n * ```ts\n * import { createRoot } from 'react-dom/client'\n * import { datadogRum } from '@datadog/browser-rum'\n * import { addReactError } from '@datadog/browser-rum-react'\n *\n * const container = document.getElementById('root')\n * const root = createRoot(container, {\n *   onUncaughtError: (error, errorInfo) => {\n *     // Report uncaught errors to Datadog\n *     addReactError(error, errorInfo)\n *   }\n * })\n * // ...\n * ```\n */\nexport function addReactError(error: Error, info: ErrorInfo) {\n  const handlingStack = createHandlingStack('react error')\n  const startClocks = clocksNow()\n  onRumStart((addEvent) => {\n    callMonitored(() => {\n      const rawError = computeRawError({\n        originalError: error,\n        handlingStack,\n        componentStack: info.componentStack ?? undefined,\n        startClocks,\n        source: ErrorSource.CUSTOM,\n        handling: ErrorHandling.HANDLED,\n        nonErrorPrefix: NonErrorPrefix.PROVIDED,\n      })\n\n      addEvent(\n        startClocks.relative,\n        {\n          type: RumEventType.ERROR,\n          date: rawError.startClocks.timeStamp,\n          error: {\n            id: generateUUID(),\n            message: rawError.message,\n            source: rawError.source,\n            stack: rawError.stack,\n            handling_stack: rawError.handlingStack,\n            component_stack: rawError.componentStack,\n            type: rawError.type,\n            handling: rawError.handling,\n            causes: rawError.causes,\n            source_type: 'browser',\n            csp: rawError.csp,\n          },\n          context: { framework: 'react', ...rawError.context },\n        },\n        {\n          error: rawError.originalError,\n          handlingStack: rawError.handlingStack,\n        }\n      )\n    })\n  })\n}\n", "import * as React from 'react'\nimport { createTimer } from './timer'\nimport { addDurationVital } from './addDurationVital'\n\n/**\n * Track the performance of a React component.\n *\n * @experimental\n */\n// eslint-disable-next-line\nexport const UNSTABLE_ReactComponentTracker = ({\n  name: componentName,\n  children,\n}: {\n  name: string\n  children?: React.ReactNode\n}) => {\n  const isFirstRender = React.useRef(true)\n\n  const renderTimer = createTimer()\n  const effectTimer = createTimer()\n  const layoutEffectTimer = createTimer()\n\n  const onEffectEnd = () => {\n    const renderDuration = renderTimer.getDuration() ?? 0\n    const effectDuration = effectTimer.getDuration() ?? 0\n    const layoutEffectDuration = layoutEffectTimer.getDuration() ?? 0\n\n    const totalRenderTime = renderDuration + effectDuration + layoutEffectDuration\n\n    addDurationVital('reactComponentRender', {\n      description: componentName,\n      startTime: renderTimer.getStartTime()!, // note: renderTimer should have been started at this point, so getStartTime should not return undefined\n      duration: totalRenderTime,\n      context: {\n        is_first_render: isFirstRender.current,\n        render_phase_duration: renderDuration,\n        effect_phase_duration: effectDuration,\n        layout_effect_phase_duration: layoutEffectDuration,\n        framework: 'react',\n      },\n    })\n\n    isFirstRender.current = false\n  }\n\n  // In react, children are rendered sequentially in the order they are defined. that's why we can\n  // measure perf timings of a component by starting recordings in the component above and stopping\n  // them in the component below.\n  return (\n    <>\n      <LifeCycle\n        onRender={renderTimer.startTimer}\n        onLayoutEffect={layoutEffectTimer.startTimer}\n        onEffect={effectTimer.startTimer}\n      />\n      {children}\n      <LifeCycle\n        onRender={renderTimer.stopTimer}\n        onLayoutEffect={layoutEffectTimer.stopTimer}\n        onEffect={() => {\n          effectTimer.stopTimer()\n          onEffectEnd()\n        }}\n      />\n    </>\n  )\n}\n\nfunction LifeCycle({\n  onRender,\n  onLayoutEffect,\n  onEffect,\n}: {\n  onRender: () => void\n  onLayoutEffect: () => void\n  onEffect: () => void\n}) {\n  onRender()\n  React.useLayoutEffect(onLayoutEffect)\n  React.useEffect(onEffect)\n  return null\n}\n", "import type { Duration, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport { elapsed, relativeNow, timeStampNow } from '@datadog/browser-core'\n\nexport function createTimer() {\n  let duration: Duration | undefined\n  let startTime: TimeStamp | undefined\n  let highPrecisionStartTime: RelativeTime | undefined\n\n  return {\n    startTimer(this: void) {\n      // timeStampNow uses Date.now() internally, which is not high precision, but this is what is\n      // used for other events, so we use it here as well.\n      startTime = timeStampNow()\n\n      // relativeNow uses performance.now() which is higher precision than Date.now(), so we use for\n      // the duration\n      highPrecisionStartTime = relativeNow()\n    },\n\n    stopTimer(this: void) {\n      duration = elapsed(highPrecisionStartTime!, relativeNow())\n    },\n\n    getDuration(this: void) {\n      return duration\n    },\n\n    getStartTime(this: void) {\n      return startTime\n    },\n  }\n}\n", "import type { RumPublicApi } from '@datadog/browser-rum-core'\nimport { onRumInit } from '../reactPlugin'\n\nexport const addDurationVital: RumPublicApi['addDurationVital'] = (name, options) => {\n  onRumInit((_, rumPublicApi) => {\n    rumPublicApi.addDurationVital(name, options)\n  })\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA,mBAAkB;;;ACElB,IAAI;AACJ,IAAI;AACJ,IAAI;AAIJ,IAAM,uBAAyC,CAAA;AAC/C,IAAM,wBAA2C,CAAA;AA6C3C,SAAU,YAAY,gBAA0C,CAAA,GAAE;AACtE,SAAO;IACL,MAAM;IACN,OAAO,EAAE,WAAW,kBAAiB,GAAE;AACrC,wBAAkB;AAClB,4BAAsB;AACtB,iBAAW,cAAc,sBAAsB;AAC7C,mBAAW,qBAAqB,eAAe;MACjD;AACA,UAAI,cAAc,QAAQ;AACxB,0BAAkB,qBAAqB;MACzC;IACF;IACA,WAAW,EAAE,SAAQ,GAAE;AACrB,uBAAiB;AACjB,iBAAW,cAAc,uBAAuB;AAC9C,YAAI,UAAU;AACZ,qBAAW,QAAQ;QACrB;MACF;IACF;IACA,4BAAyB;AACvB,aAAO,EAAE,QAAQ,CAAC,CAAC,cAAc,OAAM;IACzC;;AAEJ;AAEM,SAAU,UAAU,UAAwB;AAChD,MAAI,uBAAuB,iBAAiB;AAC1C,aAAS,qBAAqB,eAAe;EAC/C,OAAO;AACL,yBAAqB,KAAK,QAAQ;EACpC;AACF;AAEM,SAAU,WAAW,UAAyB;AAClD,MAAI,gBAAgB;AAClB,aAAS,cAAc;EACzB,OAAO;AACL,0BAAsB,KAAK,QAAQ;EACrC;AACF;;;AC7DM,SAAU,cAAc,OAAc,MAAe;AACzD,QAAM,gBAAgB,oBAAoB,aAAa;AACvD,QAAM,cAAc,UAAS;AAC7B,aAAW,CAAC,aAAY;AACtB,kBAAc,MAAK;;AACjB,YAAM,WAAW,gBAAgB;QAC/B,eAAe;QACf;QACA,iBAAgB,KAAA,KAAK,oBAAc,QAAA,OAAA,SAAA,KAAI;QACvC;QACA,QAAQ,YAAY;QACpB,UAAQ;QACR,gBAAc;OACf;AAED,eACE,YAAY,UACZ;QACE,MAAM,aAAa;QACnB,MAAM,SAAS,YAAY;QAC3B,OAAO;UACL,IAAI,aAAY;UAChB,SAAS,SAAS;UAClB,QAAQ,SAAS;UACjB,OAAO,SAAS;UAChB,gBAAgB,SAAS;UACzB,iBAAiB,SAAS;UAC1B,MAAM,SAAS;UACf,UAAU,SAAS;UACnB,QAAQ,SAAS;UACjB,aAAa;UACb,KAAK,SAAS;;QAEhB,SAAS,EAAE,WAAW,SAAS,GAAG,SAAS,QAAO;SAEpD;QACE,OAAO,SAAS;QAChB,eAAe,SAAS;OACzB;IAEL,CAAC;EACH,CAAC;AACH;;;AFvDA,IAAM,gBAAuB,EAAE,UAAU,OAAO,OAAO,KAAI;AAkBrD,IAAO,gBAAP,cAA6B,aAAAA,QAAM,UAAoC;EAC3E,YAAY,OAAyB;AACnC,UAAM,KAAK;AAQb,SAAA,aAAa,MAAK;AAChB,WAAK,SAAS,aAAa;IAC7B;AATE,SAAK,QAAQ;EACf;EAEA,OAAO,yBAAyB,OAAY;AAC1C,WAAO,EAAE,UAAU,MAAM,MAAK;EAChC;EAMA,kBAAkB,OAAc,WAAoB;AAClD,kBAAc,OAAO,SAAS;EAChC;EAEA,SAAM;AACJ,QAAI,KAAK,MAAM,UAAU;AACvB,aAAO,aAAAA,QAAM,cAAc,KAAK,MAAM,UAAU;QAC9C,OAAO,KAAK,MAAM;QAClB,YAAY,KAAK;OAClB;IACH;AAEA,WAAO,KAAK,MAAM;EACpB;;;;AGlEF,IAAAC,SAAuB;;;ACGjB,SAAU,cAAW;AACzB,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,SAAO;IACL,aAAU;AAGR,kBAAY,aAAY;AAIxB,+BAAyB,YAAW;IACtC;IAEA,YAAS;AACP,iBAAW,QAAQ,wBAAyB,YAAW,CAAE;IAC3D;IAEA,cAAW;AACT,aAAO;IACT;IAEA,eAAY;AACV,aAAO;IACT;;AAEJ;;;AC5BO,IAAM,mBAAqD,CAAC,MAAM,YAAW;AAClF,YAAU,CAAC,GAAG,iBAAgB;AAC5B,iBAAa,iBAAiB,MAAM,OAAO;EAC7C,CAAC;AACH;;;AFGO,IAAM,iCAAiC,CAAC,EAC7C,MAAM,eACN,SAAQ,MAIL;AACH,QAAM,gBAAsB,cAAO,IAAI;AAEvC,QAAM,cAAc,YAAW;AAC/B,QAAM,cAAc,YAAW;AAC/B,QAAM,oBAAoB,YAAW;AAErC,QAAM,cAAc,MAAK;;AACvB,UAAM,kBAAiB,KAAA,YAAY,YAAW,OAAE,QAAA,OAAA,SAAA,KAAI;AACpD,UAAM,kBAAiB,KAAA,YAAY,YAAW,OAAE,QAAA,OAAA,SAAA,KAAI;AACpD,UAAM,wBAAuB,KAAA,kBAAkB,YAAW,OAAE,QAAA,OAAA,SAAA,KAAI;AAEhE,UAAM,kBAAkB,iBAAiB,iBAAiB;AAE1D,qBAAiB,wBAAwB;MACvC,aAAa;MACb,WAAW,YAAY,aAAY;;MACnC,UAAU;MACV,SAAS;QACP,iBAAiB,cAAc;QAC/B,uBAAuB;QACvB,uBAAuB;QACvB,8BAA8B;QAC9B,WAAW;;KAEd;AAED,kBAAc,UAAU;EAC1B;AAKA,SACE;IAAA;IAAA;IACE,qBAAC,WAAS,EACR,UAAU,YAAY,YACtB,gBAAgB,kBAAkB,YAClC,UAAU,YAAY,WAAU,CAAA;IAEjC;IACD,qBAAC,WAAS,EACR,UAAU,YAAY,WACtB,gBAAgB,kBAAkB,WAClC,UAAU,MAAK;AACb,kBAAY,UAAS;AACrB,kBAAW;IACb,EAAC,CAAA;EACD;AAGR;AAEA,SAAS,UAAU,EACjB,UACA,gBACA,SAAQ,GAKT;AACC,WAAQ;AACR,EAAM,uBAAgB,cAAc;AACpC,EAAM,iBAAU,QAAQ;AACxB,SAAO;AACT;",
  "names": ["React", "React"]
}
