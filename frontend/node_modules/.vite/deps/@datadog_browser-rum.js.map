{
  "version": 3,
  "sources": ["../../@datadog/browser-rum/src/domain/deflate/deflateEncoder.ts", "../../@datadog/browser-rum/src/domain/scriptLoadingError.ts", "../../@datadog/browser-rum/src/domain/deflate/deflateWorker.ts", "../../@datadog/browser-rum/src/boot/isBrowserSupported.ts", "../../@datadog/browser-rum/src/domain/getSessionReplayLink.ts", "../../@datadog/browser-rum/src/domain/startRecorderInitTelemetry.ts", "../../@datadog/browser-rum/src/boot/postStartStrategy.ts", "../../@datadog/browser-rum/src/boot/preStartStrategy.ts", "../../@datadog/browser-rum/src/boot/recorderApi.ts", "../../@datadog/browser-rum/src/boot/lazyLoadRecorder.ts", "../../@datadog/browser-rum/src/domain/profiling/profilingSupported.ts", "../../@datadog/browser-rum/src/domain/profiling/profilingContext.ts", "../../@datadog/browser-rum/src/boot/lazyLoadProfiler.ts", "../../@datadog/browser-rum/src/boot/profilerApi.ts", "../../@datadog/browser-rum/src/entries/main.ts"],
  "sourcesContent": ["import type {\n  DeflateWorkerResponse,\n  DeflateEncoder,\n  DeflateEncoderStreamId,\n  DeflateWorker,\n  EncoderResult,\n  Uint8ArrayBuffer,\n} from '@datadog/browser-core'\nimport { addEventListener, concatBuffers } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\n\nexport function createDeflateEncoder(\n  configuration: RumConfiguration,\n  worker: DeflateWorker,\n  streamId: DeflateEncoderStreamId\n): DeflateEncoder {\n  let rawBytesCount = 0\n  let compressedData: Uint8ArrayBuffer[] = []\n  let compressedDataTrailer: Uint8ArrayBuffer\n\n  let isEmpty = true\n  let nextWriteActionId = 0\n  const pendingWriteActions: Array<{\n    writeCallback?: (additionalEncodedBytesCount: number) => void\n    finishCallback?: () => void\n    id: number\n    data: string\n  }> = []\n\n  const { stop: removeMessageListener } = addEventListener(\n    configuration,\n    worker,\n    'message',\n    ({ data: workerResponse }: MessageEvent<DeflateWorkerResponse>) => {\n      if (workerResponse.type !== 'wrote' || (workerResponse.streamId as DeflateEncoderStreamId) !== streamId) {\n        return\n      }\n\n      const nextPendingAction = pendingWriteActions[0]\n      if (nextPendingAction) {\n        if (nextPendingAction.id === workerResponse.id) {\n          pendingWriteActions.shift()\n\n          rawBytesCount += workerResponse.additionalBytesCount\n          compressedData.push(workerResponse.result)\n          compressedDataTrailer = workerResponse.trailer\n\n          if (nextPendingAction.writeCallback) {\n            nextPendingAction.writeCallback(workerResponse.result.byteLength)\n          } else if (nextPendingAction.finishCallback) {\n            nextPendingAction.finishCallback()\n          }\n        } else if (nextPendingAction.id < workerResponse.id) {\n          // Worker responses received out of order\n          removeMessageListener()\n        }\n      }\n    }\n  )\n\n  function consumeResult(): EncoderResult<Uint8ArrayBuffer> {\n    const output =\n      compressedData.length === 0 ? new Uint8Array(0) : concatBuffers(compressedData.concat(compressedDataTrailer))\n    const result: EncoderResult<Uint8ArrayBuffer> = {\n      rawBytesCount,\n      output,\n      outputBytesCount: output.byteLength,\n      encoding: 'deflate',\n    }\n    rawBytesCount = 0\n    compressedData = []\n    return result\n  }\n\n  function sendResetIfNeeded() {\n    if (!isEmpty) {\n      worker.postMessage({\n        action: 'reset',\n        streamId,\n      })\n      isEmpty = true\n    }\n  }\n\n  return {\n    isAsync: true,\n\n    get isEmpty() {\n      return isEmpty\n    },\n\n    write(data, callback) {\n      worker.postMessage({\n        action: 'write',\n        id: nextWriteActionId,\n        data,\n        streamId,\n      })\n      pendingWriteActions.push({\n        id: nextWriteActionId,\n        writeCallback: callback,\n        data,\n      })\n      isEmpty = false\n      nextWriteActionId += 1\n    },\n\n    finish(callback) {\n      sendResetIfNeeded()\n\n      if (!pendingWriteActions.length) {\n        callback(consumeResult())\n      } else {\n        // Make sure we do not call any write callback\n        pendingWriteActions.forEach((pendingWriteAction) => {\n          delete pendingWriteAction.writeCallback\n        })\n\n        // Wait for the last action to finish before calling the finish callback\n        pendingWriteActions[pendingWriteActions.length - 1].finishCallback = () => callback(consumeResult())\n      }\n    },\n\n    finishSync() {\n      sendResetIfNeeded()\n      const pendingData = pendingWriteActions.map((pendingWriteAction) => pendingWriteAction.data).join('')\n      // Ignore all pending write actions responses from the worker\n      pendingWriteActions.length = 0\n      return { ...consumeResult(), pendingData }\n    },\n\n    estimateEncodedBytesCount(data) {\n      // This is a rough estimation of the data size once it'll be encoded by deflate. We observed\n      // that if it's the first chunk of data pushed to the stream, the ratio is lower (3-4), but\n      // after that the ratio is greater (10+). We chose 8 here, which (on average) seems to produce\n      // requests of the expected size.\n      return data.length / 8\n    },\n\n    stop() {\n      removeMessageListener()\n    },\n  }\n}\n", "import { addTelemetryError, display, DOCS_ORIGIN } from '@datadog/browser-core'\n\nexport function reportScriptLoadingError({\n  configuredUrl,\n  error,\n  source,\n  scriptType,\n}: {\n  configuredUrl?: string | undefined\n  error: unknown\n  source: string\n  scriptType: 'module' | 'worker'\n}) {\n  display.error(`${source} failed to start: an error occurred while initializing the ${scriptType}:`, error)\n  if (error instanceof Event || (error instanceof Error && isMessageCspRelated(error.message))) {\n    let baseMessage\n    if (configuredUrl) {\n      baseMessage = `Please make sure the ${scriptType} URL ${configuredUrl} is correct and CSP is correctly configured.`\n    } else {\n      baseMessage = 'Please make sure CSP is correctly configured.'\n    }\n    display.error(\n      `${baseMessage} See documentation at ${DOCS_ORIGIN}/integrations/content_security_policy_logs/#use-csp-with-real-user-monitoring-and-session-replay`\n    )\n  } else if (scriptType === 'worker') {\n    addTelemetryError(error)\n  }\n}\n\nfunction isMessageCspRelated(message: string) {\n  return (\n    message.includes('Content Security Policy') ||\n    // Related to `require-trusted-types-for` CSP: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/require-trusted-types-for\n    message.includes(\"requires 'TrustedScriptURL'\")\n  )\n}\n", "import type { DeflateWorker, DeflateWorkerResponse } from '@datadog/browser-core'\nimport { addTelemetryError, display, addEventListener, setTimeout, ONE_SECOND } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { reportScriptLoadingError } from '../scriptLoadingError'\n\nexport const INITIALIZATION_TIME_OUT_DELAY = 30 * ONE_SECOND\n\ndeclare const __BUILD_ENV__WORKER_STRING__: string\n\n/**\n * In order to be sure that the worker is correctly working, we need a round trip of\n * initialization messages, making the creation asynchronous.\n * These worker lifecycle states handle this case.\n */\nexport const enum DeflateWorkerStatus {\n  Nil,\n  Loading,\n  Error,\n  Initialized,\n}\n\ntype DeflateWorkerState =\n  | {\n      status: DeflateWorkerStatus.Nil\n    }\n  | {\n      status: DeflateWorkerStatus.Loading\n      worker: DeflateWorker\n      stop: () => void\n      initializationFailureCallbacks: Array<() => void>\n    }\n  | {\n      status: DeflateWorkerStatus.Error\n    }\n  | {\n      status: DeflateWorkerStatus.Initialized\n      worker: DeflateWorker\n      stop: () => void\n      version: string\n    }\n\nexport type CreateDeflateWorker = typeof createDeflateWorker\n\nfunction createDeflateWorker(configuration: RumConfiguration): DeflateWorker {\n  return new Worker(configuration.workerUrl || URL.createObjectURL(new Blob([__BUILD_ENV__WORKER_STRING__])))\n}\n\nlet state: DeflateWorkerState = { status: DeflateWorkerStatus.Nil }\n\nexport function startDeflateWorker(\n  configuration: RumConfiguration,\n  source: string,\n  onInitializationFailure: () => void,\n  createDeflateWorkerImpl = createDeflateWorker\n) {\n  if (state.status === DeflateWorkerStatus.Nil) {\n    // doStartDeflateWorker updates the state to \"loading\" or \"error\"\n    doStartDeflateWorker(configuration, source, createDeflateWorkerImpl)\n  }\n\n  switch (state.status) {\n    case DeflateWorkerStatus.Loading:\n      state.initializationFailureCallbacks.push(onInitializationFailure)\n      return state.worker\n    case DeflateWorkerStatus.Initialized:\n      return state.worker\n  }\n}\n\nexport function resetDeflateWorkerState() {\n  if (state.status === DeflateWorkerStatus.Initialized || state.status === DeflateWorkerStatus.Loading) {\n    state.stop()\n  }\n  state = { status: DeflateWorkerStatus.Nil }\n}\n\nexport function getDeflateWorkerStatus() {\n  return state.status\n}\n\n/**\n * Starts the deflate worker and handle messages and errors\n *\n * The spec allow browsers to handle worker errors differently:\n * - Chromium throws an exception\n * - Firefox fires an error event\n *\n * more details: https://bugzilla.mozilla.org/show_bug.cgi?id=1736865#c2\n */\nexport function doStartDeflateWorker(\n  configuration: RumConfiguration,\n  source: string,\n  createDeflateWorkerImpl = createDeflateWorker\n) {\n  try {\n    const worker = createDeflateWorkerImpl(configuration)\n    const { stop: removeErrorListener } = addEventListener(configuration, worker, 'error', (error) => {\n      onError(configuration, source, error)\n    })\n    const { stop: removeMessageListener } = addEventListener(\n      configuration,\n      worker,\n      'message',\n      ({ data }: MessageEvent<DeflateWorkerResponse>) => {\n        if (data.type === 'errored') {\n          onError(configuration, source, data.error, data.streamId)\n        } else if (data.type === 'initialized') {\n          onInitialized(data.version)\n        }\n      }\n    )\n    worker.postMessage({ action: 'init' })\n    setTimeout(() => onTimeout(source), INITIALIZATION_TIME_OUT_DELAY)\n    const stop = () => {\n      removeErrorListener()\n      removeMessageListener()\n    }\n\n    state = { status: DeflateWorkerStatus.Loading, worker, stop, initializationFailureCallbacks: [] }\n  } catch (error) {\n    onError(configuration, source, error)\n  }\n}\n\nfunction onTimeout(source: string) {\n  if (state.status === DeflateWorkerStatus.Loading) {\n    display.error(`${source} failed to start: a timeout occurred while initializing the Worker`)\n    state.initializationFailureCallbacks.forEach((callback) => callback())\n    state = { status: DeflateWorkerStatus.Error }\n  }\n}\n\nfunction onInitialized(version: string) {\n  if (state.status === DeflateWorkerStatus.Loading) {\n    state = { status: DeflateWorkerStatus.Initialized, worker: state.worker, stop: state.stop, version }\n  }\n}\n\nfunction onError(configuration: RumConfiguration, source: string, error: unknown, streamId?: number) {\n  if (state.status === DeflateWorkerStatus.Loading || state.status === DeflateWorkerStatus.Nil) {\n    reportScriptLoadingError({\n      configuredUrl: configuration.workerUrl,\n      error,\n      source,\n      scriptType: 'worker',\n    })\n    if (state.status === DeflateWorkerStatus.Loading) {\n      state.initializationFailureCallbacks.forEach((callback) => callback())\n    }\n    state = { status: DeflateWorkerStatus.Error }\n  } else {\n    addTelemetryError(error, {\n      worker_version: state.status === DeflateWorkerStatus.Initialized && state.version,\n      stream_id: streamId,\n    })\n  }\n}\n", "/**\n * Test for Browser features used while recording\n */\nexport function isBrowserSupported() {\n  return (\n    // Array.from is a bit less supported by browsers than CSSSupportsRule, but has higher chances\n    // to be polyfilled. Test for both to be more confident. We could add more things if we find out\n    // this test is not sufficient.\n    typeof Array.from === 'function' &&\n    typeof CSSSupportsRule === 'function' &&\n    typeof URL.createObjectURL === 'function' &&\n    'forEach' in NodeList.prototype\n  )\n}\n", "import type { RumConfiguration, RumSessionManager, ViewHistory, RumSession } from '@datadog/browser-rum-core'\nimport { getSessionReplayUrl, SessionReplayState } from '@datadog/browser-rum-core'\nimport { isBrowserSupported } from '../boot/isBrowserSupported'\n\nexport function getSessionReplayLink(\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewHistory: ViewHistory,\n  isRecordingStarted: boolean\n): string | undefined {\n  const session = sessionManager.findTrackedSession()\n  const errorType = getErrorType(session, isRecordingStarted)\n  const viewContext = viewHistory.findView()\n\n  return getSessionReplayUrl(configuration, {\n    viewContext,\n    errorType,\n    session,\n  })\n}\n\nfunction getErrorType(session: RumSession | undefined, isRecordingStarted: boolean) {\n  if (!isBrowserSupported()) {\n    return 'browser-not-supported'\n  }\n  if (!session) {\n    // possibilities:\n    // - rum sampled out\n    // - session expired (edge case)\n    return 'rum-not-tracked'\n  }\n  if (session.sessionReplay === SessionReplayState.OFF) {\n    // possibilities\n    // - replay sampled out\n    return 'incorrect-session-plan'\n  }\n  if (!isRecordingStarted) {\n    return 'replay-not-started'\n  }\n}\n", "import type { Context, Duration, Telemetry, Observable, TimeStamp } from '@datadog/browser-core'\nimport { TelemetryMetrics, addTelemetryMetrics, noop, timeStampNow, elapsed } from '@datadog/browser-core'\nimport type { RecorderInitEvent } from '../boot/postStartStrategy'\n\ntype RecorderInitResult = 'aborted' | 'deflate-encoder-load-failed' | 'recorder-load-failed' | 'succeeded'\n\nexport interface RecorderInitMetrics extends Context {\n  forced: boolean\n  loadRecorderModuleDuration: number | undefined\n  recorderInitDuration: number\n  result: RecorderInitResult\n  waitForDocReadyDuration: number | undefined\n}\n\nexport function startRecorderInitTelemetry(telemetry: Telemetry, observable: Observable<RecorderInitEvent>) {\n  if (!telemetry.metricsEnabled) {\n    return { stop: noop }\n  }\n\n  let startContext:\n    | {\n        forced: boolean\n        timestamp: TimeStamp\n      }\n    | undefined\n\n  let documentReadyDuration: Duration | undefined\n  let recorderSettledDuration: Duration | undefined\n\n  const { unsubscribe } = observable.subscribe((event) => {\n    switch (event.type) {\n      case 'start':\n        startContext = { forced: event.forced, timestamp: timeStampNow() }\n        documentReadyDuration = undefined\n        recorderSettledDuration = undefined\n        break\n\n      case 'document-ready':\n        if (startContext) {\n          documentReadyDuration = elapsed(startContext.timestamp, timeStampNow())\n        }\n        break\n\n      case 'recorder-settled':\n        if (startContext) {\n          recorderSettledDuration = elapsed(startContext.timestamp, timeStampNow())\n        }\n        break\n\n      case 'aborted':\n      case 'deflate-encoder-load-failed':\n      case 'recorder-load-failed':\n      case 'succeeded':\n        // Only send metrics for the first attempt at starting the recorder.\n        unsubscribe()\n\n        if (startContext) {\n          // monitor-until: 2026-07-01\n          addTelemetryMetrics(TelemetryMetrics.RECORDER_INIT_METRICS_TELEMETRY_NAME, {\n            metrics: createRecorderInitMetrics(\n              startContext.forced,\n              recorderSettledDuration,\n              elapsed(startContext.timestamp, timeStampNow()),\n              event.type,\n              documentReadyDuration\n            ),\n          })\n        }\n        break\n    }\n  })\n\n  return { stop: unsubscribe }\n}\n\nfunction createRecorderInitMetrics(\n  forced: boolean,\n  loadRecorderModuleDuration: Duration | undefined,\n  recorderInitDuration: Duration,\n  result: RecorderInitResult,\n  waitForDocReadyDuration: Duration | undefined\n): RecorderInitMetrics {\n  return {\n    forced,\n    loadRecorderModuleDuration,\n    recorderInitDuration,\n    result,\n    waitForDocReadyDuration,\n  }\n}\n", "import type {\n  LifeCycle,\n  RumConfiguration,\n  RumSessionManager,\n  StartRecordingOptions,\n  ViewHistory,\n  RumSession,\n} from '@datadog/browser-rum-core'\nimport { LifeCycleEventType, SessionReplayState } from '@datadog/browser-rum-core'\nimport type { Telemetry, DeflateEncoder } from '@datadog/browser-core'\nimport { asyncRunOnReadyState, monitorError, Observable } from '@datadog/browser-core'\nimport { getSessionReplayLink } from '../domain/getSessionReplayLink'\nimport { startRecorderInitTelemetry } from '../domain/startRecorderInitTelemetry'\nimport type { startRecording } from './startRecording'\n\nexport type StartRecording = typeof startRecording\n\nexport const enum RecorderStatus {\n  // The recorder is stopped.\n  Stopped,\n  // The user started the recording while it wasn't possible yet. The recorder should start as soon\n  // as possible.\n  IntentToStart,\n  // The recorder is starting. It does not record anything yet.\n  Starting,\n  // The recorder is started, it records the session.\n  Started,\n}\n\nexport type RecorderInitEvent =\n  | { type: 'start'; forced: boolean }\n  | { type: 'document-ready' }\n  | { type: 'recorder-settled' }\n  | { type: 'aborted' }\n  | { type: 'deflate-encoder-load-failed' }\n  | { type: 'recorder-load-failed' }\n  | { type: 'succeeded' }\n\nexport interface Strategy {\n  start: (options?: StartRecordingOptions) => void\n  stop: () => void\n  isRecording: () => boolean\n  getSessionReplayLink: () => string | undefined\n}\n\nexport function createPostStartStrategy(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  sessionManager: RumSessionManager,\n  viewHistory: ViewHistory,\n  loadRecorder: () => Promise<StartRecording | undefined>,\n  getOrCreateDeflateEncoder: () => DeflateEncoder | undefined,\n  telemetry: Telemetry\n): Strategy {\n  let status = RecorderStatus.Stopped\n  let stopRecording: () => void\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_EXPIRED, () => {\n    if (status === RecorderStatus.Starting || status === RecorderStatus.Started) {\n      stop()\n      status = RecorderStatus.IntentToStart\n    }\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    if (status === RecorderStatus.IntentToStart) {\n      start()\n    }\n  })\n\n  const observable = new Observable<RecorderInitEvent>()\n  startRecorderInitTelemetry(telemetry, observable)\n\n  const doStart = async (forced: boolean) => {\n    observable.notify({ type: 'start', forced })\n\n    const [startRecordingImpl] = await Promise.all([\n      notifyWhenSettled(observable, { type: 'recorder-settled' }, loadRecorder()),\n      notifyWhenSettled(observable, { type: 'document-ready' }, asyncRunOnReadyState(configuration, 'interactive')),\n    ])\n\n    if (status !== RecorderStatus.Starting) {\n      observable.notify({ type: 'aborted' })\n      return\n    }\n\n    if (!startRecordingImpl) {\n      status = RecorderStatus.Stopped\n      observable.notify({ type: 'recorder-load-failed' })\n      return\n    }\n\n    const deflateEncoder = getOrCreateDeflateEncoder()\n    if (!deflateEncoder) {\n      status = RecorderStatus.Stopped\n      observable.notify({ type: 'deflate-encoder-load-failed' })\n      return\n    }\n\n    ;({ stop: stopRecording } = startRecordingImpl(\n      lifeCycle,\n      configuration,\n      sessionManager,\n      viewHistory,\n      deflateEncoder,\n      telemetry\n    ))\n\n    status = RecorderStatus.Started\n    observable.notify({ type: 'succeeded' })\n  }\n\n  function start(options?: StartRecordingOptions) {\n    const session = sessionManager.findTrackedSession()\n    if (canStartRecording(session, options)) {\n      status = RecorderStatus.IntentToStart\n      return\n    }\n\n    if (isRecordingInProgress(status)) {\n      return\n    }\n\n    status = RecorderStatus.Starting\n\n    const forced = shouldForceReplay(session!, options) || false\n\n    // Intentionally not awaiting doStart() to keep it asynchronous\n    doStart(forced).catch(monitorError)\n\n    if (forced) {\n      sessionManager.setForcedReplay()\n    }\n  }\n\n  function stop() {\n    if (status === RecorderStatus.Started) {\n      stopRecording?.()\n    }\n\n    status = RecorderStatus.Stopped\n  }\n\n  return {\n    start,\n    stop,\n    getSessionReplayLink() {\n      return getSessionReplayLink(configuration, sessionManager, viewHistory, status !== RecorderStatus.Stopped)\n    },\n    isRecording: () => status === RecorderStatus.Started,\n  }\n}\n\nfunction canStartRecording(session: RumSession | undefined, options?: StartRecordingOptions) {\n  return !session || (session.sessionReplay === SessionReplayState.OFF && (!options || !options.force))\n}\n\nfunction isRecordingInProgress(status: RecorderStatus) {\n  return status === RecorderStatus.Starting || status === RecorderStatus.Started\n}\n\nfunction shouldForceReplay(session: RumSession, options?: StartRecordingOptions) {\n  return options && options.force && session.sessionReplay === SessionReplayState.OFF\n}\n\nasync function notifyWhenSettled<Event, Result>(\n  observable: Observable<Event>,\n  event: Event,\n  promise: Promise<Result>\n): Promise<Result> {\n  try {\n    return await promise\n  } finally {\n    observable.notify(event)\n  }\n}\n", "import { noop } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { Strategy } from './postStartStrategy'\n\nconst enum PreStartRecorderStatus {\n  None,\n  HadManualStart,\n  HadManualStop,\n}\n\nexport function createPreStartStrategy(): {\n  strategy: Strategy\n  shouldStartImmediately: (configuration: RumConfiguration) => boolean\n} {\n  let status = PreStartRecorderStatus.None\n  return {\n    strategy: {\n      start() {\n        status = PreStartRecorderStatus.HadManualStart\n      },\n      stop() {\n        status = PreStartRecorderStatus.HadManualStop\n      },\n      isRecording: () => false,\n      getSessionReplayLink: noop as () => string | undefined,\n    },\n    shouldStartImmediately(configuration) {\n      return (\n        status === PreStartRecorderStatus.HadManualStart ||\n        (status === PreStartRecorderStatus.None && !configuration.startSessionReplayRecordingManually)\n      )\n    },\n  }\n}\n", "import type { DeflateEncoder, DeflateWorker, Telemetry } from '@datadog/browser-core'\nimport {\n  canUseEventBridge,\n  noop,\n  BridgeCapability,\n  bridgeSupports,\n  DeflateEncoderStreamId,\n} from '@datadog/browser-core'\nimport type {\n  LifeCycle,\n  ViewHistory,\n  RumSessionManager,\n  RecorderApi,\n  RumConfiguration,\n  StartRecordingOptions,\n} from '@datadog/browser-rum-core'\nimport { getReplayStats as getReplayStatsImpl } from '../domain/replayStats'\nimport type { CreateDeflateWorker } from '../domain/deflate'\nimport {\n  createDeflateEncoder,\n  DeflateWorkerStatus,\n  getDeflateWorkerStatus,\n  startDeflateWorker,\n} from '../domain/deflate'\nimport { isBrowserSupported } from './isBrowserSupported'\nimport type { StartRecording } from './postStartStrategy'\nimport { createPostStartStrategy } from './postStartStrategy'\nimport { createPreStartStrategy } from './preStartStrategy'\n\nexport function makeRecorderApi(\n  loadRecorder: () => Promise<StartRecording | undefined>,\n  createDeflateWorkerImpl?: CreateDeflateWorker\n): RecorderApi {\n  if ((canUseEventBridge() && !bridgeSupports(BridgeCapability.RECORDS)) || !isBrowserSupported()) {\n    return {\n      start: noop,\n      stop: noop,\n      getReplayStats: () => undefined,\n      onRumStart: noop,\n      isRecording: () => false,\n      getSessionReplayLink: () => undefined,\n    }\n  }\n\n  // eslint-disable-next-line prefer-const\n  let { strategy, shouldStartImmediately } = createPreStartStrategy()\n\n  return {\n    start: (options?: StartRecordingOptions) => strategy.start(options),\n    stop: () => strategy.stop(),\n    getSessionReplayLink: () => strategy.getSessionReplayLink(),\n    onRumStart,\n    isRecording: () =>\n      // The worker is started optimistically, meaning we could have started to record but its\n      // initialization fails a bit later. This could happen when:\n      // * the worker URL (blob or plain URL) is blocked by CSP in Firefox only (Chromium and Safari\n      // throw an exception when instantiating the worker, and IE doesn't care about CSP)\n      // * the browser fails to load the worker in case the workerUrl is used\n      // * an unexpected error occurs in the Worker before initialization, ex:\n      //   * a runtime exception collected by monitor()\n      //   * a syntax error notified by the browser via an error event\n      // * the worker is unresponsive for some reason and timeouts\n      //\n      // It is not expected to happen often. Nonetheless, the \"replayable\" status on RUM events is\n      // an important part of the Datadog App:\n      // * If we have a false positive (we set has_replay: true even if no replay data is present),\n      // we might display broken links to the Session Replay player.\n      // * If we have a false negative (we don't set has_replay: true even if replay data is\n      // available), it is less noticeable because no link will be displayed.\n      //\n      // Thus, it is better to have false negative, so let's make sure the worker is correctly\n      // initialized before advertizing that we are recording.\n      //\n      // In the future, when the compression worker will also be used for RUM data, this will be\n      // less important since no RUM event will be sent when the worker fails to initialize.\n      getDeflateWorkerStatus() === DeflateWorkerStatus.Initialized && strategy.isRecording(),\n\n    getReplayStats: (viewId) =>\n      getDeflateWorkerStatus() === DeflateWorkerStatus.Initialized ? getReplayStatsImpl(viewId) : undefined,\n  }\n\n  function onRumStart(\n    lifeCycle: LifeCycle,\n    configuration: RumConfiguration,\n    sessionManager: RumSessionManager,\n    viewHistory: ViewHistory,\n    worker: DeflateWorker | undefined,\n    telemetry: Telemetry\n  ) {\n    let cachedDeflateEncoder: DeflateEncoder | undefined\n\n    function getOrCreateDeflateEncoder() {\n      if (!cachedDeflateEncoder) {\n        worker ??= startDeflateWorker(\n          configuration,\n          'Datadog Session Replay',\n          () => {\n            strategy.stop()\n          },\n          createDeflateWorkerImpl\n        )\n\n        if (worker) {\n          cachedDeflateEncoder = createDeflateEncoder(configuration, worker, DeflateEncoderStreamId.REPLAY)\n        }\n      }\n      return cachedDeflateEncoder\n    }\n\n    strategy = createPostStartStrategy(\n      configuration,\n      lifeCycle,\n      sessionManager,\n      viewHistory,\n      loadRecorder,\n      getOrCreateDeflateEncoder,\n      telemetry\n    )\n\n    if (shouldStartImmediately(configuration)) {\n      strategy.start()\n    }\n  }\n}\n", "import { reportScriptLoadingError } from '../domain/scriptLoadingError'\nimport type { startRecording } from './startRecording'\n\nexport async function lazyLoadRecorder(\n  importRecorderImpl = importRecorder\n): Promise<typeof startRecording | undefined> {\n  try {\n    return await importRecorderImpl()\n  } catch (error: unknown) {\n    reportScriptLoadingError({\n      error,\n      source: 'Recorder',\n      scriptType: 'module',\n    })\n  }\n}\n\nasync function importRecorder() {\n  const module = await import(/* webpackChunkName: \"recorder\" */ './startRecording')\n  return module.startRecording\n}\n", "import { getGlobalObject } from '@datadog/browser-core'\nimport type { Profiler } from './types'\n\nexport function isProfilingSupported(): boolean {\n  const globalThis = getGlobalObject()\n\n  // This API might be unavailable in some browsers\n  const globalThisProfiler: Profiler | undefined = (globalThis as any).Profiler\n  return globalThisProfiler !== undefined\n}\n", "import { HookNames, SKIPPED } from '@datadog/browser-core'\nimport type { Hooks, ProfilingInternalContextSchema } from '@datadog/browser-rum-core'\nimport { RumEventType } from '@datadog/browser-rum-core'\n\nexport interface ProfilingContextManager {\n  set: (next: ProfilingInternalContextSchema) => void\n  get: () => ProfilingInternalContextSchema | undefined\n}\n\nexport function startProfilingContext(hooks: Hooks): ProfilingContextManager {\n  let currentContext: ProfilingInternalContextSchema = {\n    status: 'starting',\n  }\n\n  hooks.register(HookNames.Assemble, ({ eventType }) => {\n    if (eventType !== RumEventType.VIEW && eventType !== RumEventType.LONG_TASK) {\n      return SKIPPED\n    }\n\n    return {\n      type: eventType,\n      _dd: {\n        profiling: currentContext,\n      },\n    }\n  })\n\n  return {\n    get: () => currentContext,\n    set: (newContext: ProfilingInternalContextSchema) => {\n      currentContext = newContext\n    },\n  }\n}\n", "import { reportScriptLoadingError } from '../domain/scriptLoadingError'\nimport type { createRumProfiler } from '../domain/profiling/profiler'\n\nexport async function lazyLoadProfiler(\n  importProfilerImpl = importProfiler\n): Promise<typeof createRumProfiler | undefined> {\n  try {\n    return await importProfilerImpl()\n  } catch (error: unknown) {\n    reportScriptLoadingError({\n      error,\n      source: 'Profiler',\n      scriptType: 'module',\n    })\n  }\n}\n\nasync function importProfiler() {\n  const module = await import(/* webpackChunkName: \"profiler\" */ '../domain/profiling/profiler')\n  return module.createRumProfiler\n}\n", "import type {\n  LifeCycle,\n  ViewHistory,\n  RumSessionManager,\n  RumConfiguration,\n  ProfilerApi,\n  Hooks,\n  LongTaskContexts,\n} from '@datadog/browser-rum-core'\nimport type { DeflateEncoderStreamId, Encoder } from '@datadog/browser-core'\nimport { isSampled } from '@datadog/browser-rum-core'\nimport { addTelemetryDebug, monitorError } from '@datadog/browser-core'\nimport type { RUMProfiler } from '../domain/profiling/types'\nimport { isProfilingSupported } from '../domain/profiling/profilingSupported'\nimport { startProfilingContext } from '../domain/profiling/profilingContext'\nimport { lazyLoadProfiler } from './lazyLoadProfiler'\n\nexport function makeProfilerApi(): ProfilerApi {\n  let profiler: RUMProfiler | undefined\n\n  function onRumStart(\n    lifeCycle: LifeCycle,\n    hooks: Hooks,\n    configuration: RumConfiguration,\n    sessionManager: RumSessionManager,\n    viewHistory: ViewHistory,\n    longTaskContexts: LongTaskContexts,\n    createEncoder: (streamId: DeflateEncoderStreamId) => Encoder\n  ) {\n    const session = sessionManager.findTrackedSession() // Check if the session is tracked.\n\n    if (!session) {\n      // No session tracked, no profiling.\n      // Note: No Profiling context is set at this stage.\n      return\n    }\n\n    // Sampling (sticky sampling based on session id)\n    if (!isSampled(session.id, configuration.profilingSampleRate)) {\n      // No sampling, no profiling.\n      // Note: No Profiling context is set at this stage.\n      return\n    }\n\n    // Listen to events and add the profiling context to them.\n    const profilingContextManager = startProfilingContext(hooks)\n\n    // Browser support check\n    if (!isProfilingSupported()) {\n      profilingContextManager.set({\n        status: 'error',\n        error_reason: 'not-supported-by-browser',\n      })\n      return\n    }\n\n    lazyLoadProfiler()\n      .then((createRumProfiler) => {\n        if (!createRumProfiler) {\n          // monitor-until: 2026-01-01, reconsider after profiling GA\n          addTelemetryDebug('[DD_RUM] Failed to lazy load the RUM Profiler')\n          profilingContextManager.set({ status: 'error', error_reason: 'failed-to-lazy-load' })\n          return\n        }\n\n        profiler = createRumProfiler(\n          configuration,\n          lifeCycle,\n          sessionManager,\n          profilingContextManager,\n          longTaskContexts,\n          createEncoder,\n          viewHistory,\n          undefined\n        )\n        profiler.start()\n      })\n      .catch(monitorError)\n  }\n\n  return {\n    onRumStart,\n    stop: () => {\n      profiler?.stop().catch(monitorError)\n    },\n  }\n}\n", "/**\n * Datadog Browser RUM SDK - Full version with Session Replay and Real User Profiling capabilities.\n * Use this package to monitor your web application's performance and user experience.\n *\n * @packageDocumentation\n * @see [RUM Browser Monitoring Setup](https://docs.datadoghq.com/real_user_monitoring/browser/)\n */\n\n// Keep the following in sync with packages/rum-slim/src/entries/main.ts\nimport { defineGlobal, getGlobalObject } from '@datadog/browser-core'\nimport type { RumPublicApi } from '@datadog/browser-rum-core'\nimport { makeRumPublicApi, startRum } from '@datadog/browser-rum-core'\nimport { makeRecorderApi } from '../boot/recorderApi'\nimport { createDeflateEncoder, startDeflateWorker } from '../domain/deflate'\nimport { lazyLoadRecorder } from '../boot/lazyLoadRecorder'\nimport { makeProfilerApi } from '../boot/profilerApi'\n\nexport type {\n  User,\n  Account,\n  TraceContextInjection,\n  SessionPersistence,\n  TrackingConsent,\n  MatchOption,\n  ProxyFn,\n  Site,\n  Context,\n  ContextValue,\n  ContextArray,\n  RumInternalContext,\n} from '@datadog/browser-core'\nexport { DefaultPrivacyLevel } from '@datadog/browser-core'\n\n/**\n * @deprecated Use {@link DatadogRum} instead\n */\nexport type RumGlobal = RumPublicApi\n\nexport type {\n  RumPublicApi as DatadogRum,\n  RumInitConfiguration,\n  ViewOptions,\n  StartRecordingOptions,\n  AddDurationVitalOptions,\n  DurationVitalOptions,\n  DurationVitalReference,\n  TracingOption,\n  RumPlugin,\n  OnRumStartOptions,\n  PropagatorType,\n  FeatureFlagsForEvents,\n\n  // Events\n  CommonProperties,\n  RumEvent,\n  RumActionEvent,\n  RumErrorEvent,\n  RumLongTaskEvent,\n  RumResourceEvent,\n  RumViewEvent,\n  RumVitalEvent,\n\n  // Events context\n  RumEventDomainContext,\n  RumViewEventDomainContext,\n  RumErrorEventDomainContext,\n  RumActionEventDomainContext,\n  RumVitalEventDomainContext,\n  RumFetchResourceEventDomainContext,\n  RumXhrResourceEventDomainContext,\n  RumOtherResourceEventDomainContext,\n  RumLongTaskEventDomainContext,\n} from '@datadog/browser-rum-core'\n\nconst recorderApi = makeRecorderApi(lazyLoadRecorder)\n\nconst profilerApi = makeProfilerApi()\n\n/**\n * The global RUM instance. Use this to call RUM methods.\n *\n * @category Main\n * @see {@link DatadogRum}\n * @see [RUM Browser Monitoring Setup](https://docs.datadoghq.com/real_user_monitoring/browser/)\n */\nexport const datadogRum = makeRumPublicApi(startRum, recorderApi, profilerApi, {\n  startDeflateWorker,\n  createDeflateEncoder,\n  sdkName: 'rum',\n})\n\ninterface BrowserWindow extends Window {\n  DD_RUM?: RumPublicApi\n}\ndefineGlobal(getGlobalObject<BrowserWindow>(), 'DD_RUM', datadogRum)\n"],
  "mappings": "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",
  "names": []
}
