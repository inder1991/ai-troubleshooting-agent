{
  "version": 3,
  "sources": ["../../@datadog/browser-rum/src/types/sessionReplayConstants.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializationUtils.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializeStyleSheets.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializeAttribute.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializeAttributes.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializeNode.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializeDocument.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializationStats.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializationTransaction.ts", "../../@datadog/browser-rum/src/domain/record/viewports.ts", "../../@datadog/browser-rum/src/domain/record/startFullSnapshots.ts", "../../@datadog/browser-rum/src/domain/record/itemIds.ts", "../../@datadog/browser-rum/src/domain/record/recordingScope.ts", "../../@datadog/browser-rum/src/domain/record/elementsScrollPositions.ts", "../../@datadog/browser-rum/src/domain/record/eventsUtils.ts", "../../@datadog/browser-rum/src/domain/record/assembly.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackMove.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackMouseInteraction.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackScroll.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackViewportResize.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackMediaInteraction.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackStyleSheet.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackFocus.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackFrustration.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackViewEnd.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackInput.ts", "../../@datadog/browser-rum/src/domain/record/mutationBatch.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackMutation.ts", "../../@datadog/browser-rum/src/domain/record/shadowRootsController.ts", "../../@datadog/browser-rum/src/domain/record/record.ts", "../../@datadog/browser-rum/src/domain/segmentCollection/buildReplayPayload.ts", "../../@datadog/browser-rum/src/domain/segmentCollection/segment.ts", "../../@datadog/browser-rum/src/domain/segmentCollection/segmentCollection.ts", "../../@datadog/browser-rum/src/domain/segmentCollection/startSegmentTelemetry.ts", "../../@datadog/browser-rum/src/domain/startRecordBridge.ts", "../../@datadog/browser-rum/src/boot/startRecording.ts"],
  "sourcesContent": ["import type * as SessionReplay from './sessionReplay'\n\nexport const RecordType: {\n  FullSnapshot: SessionReplay.BrowserFullSnapshotRecord['type']\n  IncrementalSnapshot: SessionReplay.BrowserIncrementalSnapshotRecord['type']\n  Meta: SessionReplay.MetaRecord['type']\n  Focus: SessionReplay.FocusRecord['type']\n  ViewEnd: SessionReplay.ViewEndRecord['type']\n  VisualViewport: SessionReplay.VisualViewportRecord['type']\n  FrustrationRecord: SessionReplay.FrustrationRecord['type']\n  Change: SessionReplay.BrowserChangeRecord['type']\n} = {\n  FullSnapshot: 2,\n  IncrementalSnapshot: 3,\n  Meta: 4,\n  Focus: 6,\n  ViewEnd: 7,\n  VisualViewport: 8,\n  FrustrationRecord: 9,\n  Change: 12,\n} as const\n\nexport type RecordType = (typeof RecordType)[keyof typeof RecordType]\n\nexport const NodeType: {\n  Document: SessionReplay.DocumentNode['type']\n  DocumentType: SessionReplay.DocumentTypeNode['type']\n  Element: SessionReplay.ElementNode['type']\n  Text: SessionReplay.TextNode['type']\n  CDATA: SessionReplay.CDataNode['type']\n  DocumentFragment: SessionReplay.DocumentFragmentNode['type']\n} = {\n  Document: 0,\n  DocumentType: 1,\n  Element: 2,\n  Text: 3,\n  CDATA: 4,\n  DocumentFragment: 11,\n} as const\n\nexport type NodeType = (typeof NodeType)[keyof typeof NodeType]\n\n// ChangeTypeId evaluates to Id if [Id, ...Data[]] is a valid variant of Change;\n// otherwise, it triggers a compile-time error.\ntype ChangeTypeId<Id, Data> = [Id, ...Data[]] extends SessionReplay.Change ? Id : never\n\nexport const ChangeType: {\n  AddString: ChangeTypeId<0, SessionReplay.AddStringChange>\n  AddNode: ChangeTypeId<1, SessionReplay.AddNodeChange>\n  RemoveNode: ChangeTypeId<2, SessionReplay.RemoveNodeChange>\n  Attribute: ChangeTypeId<3, SessionReplay.AttributeChange>\n  Text: ChangeTypeId<4, SessionReplay.TextChange>\n  Size: ChangeTypeId<5, SessionReplay.SizeChange>\n  ScrollPosition: ChangeTypeId<6, SessionReplay.ScrollPositionChange>\n  AddStyleSheet: ChangeTypeId<7, SessionReplay.AddStyleSheetChange>\n  AttachedStyleSheets: ChangeTypeId<8, SessionReplay.AttachedStyleSheetsChange>\n  MediaPlaybackState: ChangeTypeId<9, SessionReplay.MediaPlaybackStateChange>\n  VisualViewport: ChangeTypeId<10, SessionReplay.VisualViewportChange>\n} = {\n  AddString: 0,\n  AddNode: 1,\n  RemoveNode: 2,\n  Attribute: 3,\n  Text: 4,\n  Size: 5,\n  ScrollPosition: 6,\n  AddStyleSheet: 7,\n  AttachedStyleSheets: 8,\n  MediaPlaybackState: 9,\n  VisualViewport: 10,\n} as const\n\nexport type ChangeType = (typeof ChangeType)[keyof typeof ChangeType]\n\nexport const PlaybackState: {\n  Playing: SessionReplay.PlaybackStatePlaying\n  Paused: SessionReplay.PlaybackStatePaused\n} = {\n  Playing: 0,\n  Paused: 1,\n} as const\n\nexport type PlaybackState = (typeof PlaybackState)[keyof typeof PlaybackState]\n\nexport const IncrementalSource: {\n  Mutation: SessionReplay.BrowserMutationData['source']\n  MouseMove: Exclude<SessionReplay.MousemoveData['source'], 6>\n  MouseInteraction: SessionReplay.MouseInteractionData['source']\n  Scroll: SessionReplay.ScrollData['source']\n  ViewportResize: SessionReplay.ViewportResizeData['source']\n  Input: SessionReplay.InputData['source']\n  TouchMove: Exclude<SessionReplay.MousemoveData['source'], 1>\n  MediaInteraction: SessionReplay.MediaInteractionData['source']\n  StyleSheetRule: SessionReplay.StyleSheetRuleData['source']\n} = {\n  Mutation: 0,\n  MouseMove: 1,\n  MouseInteraction: 2,\n  Scroll: 3,\n  ViewportResize: 4,\n  Input: 5,\n  TouchMove: 6,\n  MediaInteraction: 7,\n  StyleSheetRule: 8,\n  // CanvasMutation : 9,\n  // Font : 10,\n} as const\n\nexport type IncrementalSource = (typeof IncrementalSource)[keyof typeof IncrementalSource]\n\nexport const MouseInteractionType = {\n  MouseUp: 0,\n  MouseDown: 1,\n  Click: 2,\n  ContextMenu: 3,\n  DblClick: 4,\n  Focus: 5,\n  Blur: 6,\n  TouchStart: 7,\n  TouchEnd: 9,\n} as const\n\nexport type MouseInteractionType = (typeof MouseInteractionType)[keyof typeof MouseInteractionType]\n\nexport const MediaInteractionType = {\n  Play: 0,\n  Pause: 1,\n} as const\n\nexport type MediaInteractionType = (typeof MediaInteractionType)[keyof typeof MediaInteractionType]\n", "import { buildUrl } from '@datadog/browser-core'\nimport { CENSORED_STRING_MARK, shouldMaskNode } from '@datadog/browser-rum-core'\nimport type { NodePrivacyLevel } from '@datadog/browser-rum-core'\n\n/**\n * Get the element \"value\" to be serialized as an attribute or an input update record. It respects\n * the input privacy mode of the element.\n * PERFROMANCE OPTIMIZATION: Assumes that privacy level `HIDDEN` is never encountered because of earlier checks.\n */\nexport function getElementInputValue(element: Element, nodePrivacyLevel: NodePrivacyLevel) {\n  /*\n   BROWSER SPEC NOTE: <input>, <select>\n   For some <input> elements, the `value` is an exceptional property/attribute that has the\n   value synced between el.value and el.getAttribute()\n   input[type=button,checkbox,hidden,image,radio,reset,submit]\n   */\n  const tagName = element.tagName\n  const value = (element as HTMLInputElement | HTMLTextAreaElement).value\n\n  if (shouldMaskNode(element, nodePrivacyLevel)) {\n    const type = (element as HTMLInputElement | HTMLTextAreaElement).type\n    if (tagName === 'INPUT' && (type === 'button' || type === 'submit' || type === 'reset')) {\n      // Overrule `MASK` privacy level for button-like element values, as they are used during replay\n      // to display their label. They can still be hidden via the \"hidden\" privacy attribute or class name.\n      return value\n    } else if (!value || tagName === 'OPTION') {\n      // <Option> value provides no benefit\n      return\n    }\n    return CENSORED_STRING_MARK\n  }\n\n  if (tagName === 'OPTION' || tagName === 'SELECT') {\n    return (element as HTMLOptionElement | HTMLSelectElement).value\n  }\n\n  if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {\n    return\n  }\n\n  return value\n}\n\nexport const URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm\nexport const ABSOLUTE_URL = /^[A-Za-z]+:|^\\/\\//\nexport const DATA_URI = /^[\"']?data:.*,/i\n\nexport function switchToAbsoluteUrl(cssText: string, cssHref: string | null): string {\n  return cssText.replace(\n    URL_IN_CSS_REF,\n    (\n      matchingSubstring: string,\n      singleQuote: string | undefined,\n      urlWrappedInSingleQuotes: string | undefined,\n      doubleQuote: string | undefined,\n      urlWrappedInDoubleQuotes: string | undefined,\n      urlNotWrappedInQuotes: string | undefined\n    ) => {\n      const url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes\n\n      if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {\n        return matchingSubstring\n      }\n\n      const quote = singleQuote || doubleQuote || ''\n      return `url(${quote}${makeUrlAbsolute(url, cssHref)}${quote})`\n    }\n  )\n}\n\nfunction makeUrlAbsolute(url: string, baseUrl: string): string {\n  try {\n    return buildUrl(url, baseUrl).href\n  } catch {\n    return url\n  }\n}\n\nconst TAG_NAME_REGEX = /[^a-z1-6-_]/\nexport function getValidTagName(tagName: string): string {\n  const processedTagName = tagName.toLowerCase().trim()\n\n  if (TAG_NAME_REGEX.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div'\n  }\n\n  return processedTagName\n}\n\n/**\n * Returns the tag name of the given element, normalized to ensure a consistent lowercase\n * representation regardless of whether the element is HTML, XHTML, or SVG.\n */\nexport function normalizedTagName(element: Element): string {\n  return element.tagName.toLowerCase()\n}\n\nexport function censoredImageForSize(width: number, height: number) {\n  return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' style='background-color:silver'%3E%3C/svg%3E`\n}\n", "import type { StyleSheet } from '../../../types'\n\nexport function serializeStyleSheets(cssStyleSheets: CSSStyleSheet[] | undefined): StyleSheet[] | undefined {\n  if (cssStyleSheets === undefined || cssStyleSheets.length === 0) {\n    return undefined\n  }\n  return cssStyleSheets.map((cssStyleSheet) => {\n    const rules = cssStyleSheet.cssRules || cssStyleSheet.rules\n    const cssRules = Array.from(rules, (cssRule) => cssRule.cssText)\n\n    const styleSheet: StyleSheet = {\n      cssRules,\n      disabled: cssStyleSheet.disabled || undefined,\n      media: cssStyleSheet.media.length > 0 ? Array.from(cssStyleSheet.media) : undefined,\n    }\n    return styleSheet\n  })\n}\n", "import {\n  NodePrivacyLevel,\n  CENSORED_STRING_MARK,\n  CENSORED_IMG_MARK,\n  sanitizeIfLongDataUrl,\n  shouldMaskAttribute,\n} from '@datadog/browser-rum-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { censoredImageForSize } from './serializationUtils'\n\n// TODO: temporarily bump the Session Replay limit to 1Mb for dataUrls\n// This limit should be removed after [PANA-2843] is implemented\nexport const MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 1_000_000\n\nexport function serializeAttribute(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  attributeName: string,\n  configuration: RumConfiguration\n): string | null {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // dup condition for direct access case\n    return null\n  }\n\n  const attributeValue = element.getAttribute(attributeName)\n  const tagName = element.tagName\n  if (shouldMaskAttribute(tagName, attributeName, attributeValue, nodePrivacyLevel, configuration)) {\n    // mask image URLs\n    if (tagName === 'IMG') {\n      // generate image with similar dimension than the original to have the same rendering behaviour\n      const image = element as HTMLImageElement\n      if (image.naturalWidth > 0) {\n        return censoredImageForSize(image.naturalWidth, image.naturalHeight)\n      }\n      const { width, height } = element.getBoundingClientRect()\n      if (width > 0 || height > 0) {\n        return censoredImageForSize(width, height)\n      }\n      // if we can't get the image size, fallback to the censored image\n      return CENSORED_IMG_MARK\n    }\n    if (tagName === 'SOURCE') {\n      return CENSORED_IMG_MARK\n    }\n\n    return CENSORED_STRING_MARK\n  }\n\n  if (!attributeValue) {\n    return attributeValue\n  }\n\n  return sanitizeIfLongDataUrl(attributeValue, MAX_ATTRIBUTE_VALUE_CHAR_LENGTH)\n}\n", "import { NodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core'\nimport { isSafari } from '@datadog/browser-core'\nimport { getElementInputValue, normalizedTagName, switchToAbsoluteUrl } from './serializationUtils'\nimport { serializeAttribute } from './serializeAttribute'\nimport type { SerializationTransaction } from './serializationTransaction'\nimport { SerializationKind } from './serializationTransaction'\nimport type { VirtualAttributes } from './serialization.types'\n\nexport function serializeAttributes(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  transaction: SerializationTransaction\n): Record<string, number | string> {\n  return {\n    ...serializeDOMAttributes(element, nodePrivacyLevel, transaction),\n    ...serializeVirtualAttributes(element, nodePrivacyLevel, transaction),\n  }\n}\n\nexport function serializeDOMAttributes(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  transaction: SerializationTransaction\n): Record<string, string> {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return {}\n  }\n\n  const attrs: Record<string, string> = {}\n  const tagName = normalizedTagName(element)\n\n  for (let i = 0; i < element.attributes.length; i += 1) {\n    const attribute = element.attributes.item(i)!\n    const attributeName = attribute.name\n    const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, transaction.scope.configuration)\n    if (attributeValue !== null) {\n      attrs[attributeName] = attributeValue\n    }\n  }\n\n  if (\n    (element as HTMLInputElement).value &&\n    (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')\n  ) {\n    const formValue = getElementInputValue(element, nodePrivacyLevel)\n    if (formValue !== undefined) {\n      attrs.value = formValue\n    }\n  }\n\n  /**\n   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n   */\n  if (tagName === 'option') {\n    const optionElement = element as HTMLOptionElement\n    if (optionElement.selected && !shouldMaskNode(optionElement, nodePrivacyLevel)) {\n      attrs.selected = ''\n    } else {\n      delete attrs.selected\n    }\n  }\n\n  /**\n   * Forms: input[type=checkbox,radio]\n   * The `checked` property for <input> is a little bit special:\n   * 1. el.checked is a setter that returns if truthy.\n   * 2. getAttribute returns the string value\n   * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n   */\n  const inputElement = element as HTMLInputElement\n  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n    if (inputElement.checked && !shouldMaskNode(inputElement, nodePrivacyLevel)) {\n      attrs.checked = ''\n    } else {\n      delete attrs.checked\n    }\n  }\n\n  return attrs\n}\n\nexport function serializeVirtualAttributes(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  transaction: SerializationTransaction\n): VirtualAttributes {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return {}\n  }\n\n  const attrs: VirtualAttributes = {}\n  const doc = element.ownerDocument\n  const tagName = normalizedTagName(element)\n\n  // remote css\n  if (tagName === 'link') {\n    const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === (element as HTMLLinkElement).href)\n    const cssText = getCssRulesString(stylesheet)\n    if (cssText && stylesheet) {\n      transaction.addMetric('cssText', cssText.length)\n      attrs._cssText = cssText\n    }\n  }\n\n  // dynamic stylesheet\n  if (tagName === 'style' && (element as HTMLStyleElement).sheet) {\n    const cssText = getCssRulesString((element as HTMLStyleElement).sheet)\n    if (cssText) {\n      transaction.addMetric('cssText', cssText.length)\n      attrs._cssText = cssText\n    }\n  }\n\n  /**\n   * Serialize the media playback state\n   */\n  if (tagName === 'audio' || tagName === 'video') {\n    const mediaElement = element as HTMLMediaElement\n    attrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played'\n  }\n\n  /**\n   * Serialize the scroll state for each element only for full snapshot\n   */\n  let scrollTop: number | undefined\n  let scrollLeft: number | undefined\n  switch (transaction.kind) {\n    case SerializationKind.INITIAL_FULL_SNAPSHOT:\n      scrollTop = Math.round(element.scrollTop)\n      scrollLeft = Math.round(element.scrollLeft)\n      if (scrollTop || scrollLeft) {\n        transaction.scope.elementsScrollPositions.set(element, { scrollTop, scrollLeft })\n      }\n      break\n    case SerializationKind.SUBSEQUENT_FULL_SNAPSHOT:\n      if (transaction.scope.elementsScrollPositions.has(element)) {\n        ;({ scrollTop, scrollLeft } = transaction.scope.elementsScrollPositions.get(element)!)\n      }\n      break\n  }\n  if (scrollLeft) {\n    attrs.rr_scrollLeft = scrollLeft\n  }\n  if (scrollTop) {\n    attrs.rr_scrollTop = scrollTop\n  }\n\n  return attrs\n}\n\nexport function getCssRulesString(cssStyleSheet: CSSStyleSheet | undefined | null): string | null {\n  if (!cssStyleSheet) {\n    return null\n  }\n  let rules: CSSRuleList | undefined\n  try {\n    rules = cssStyleSheet.rules || cssStyleSheet.cssRules\n  } catch {\n    // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n  }\n  if (!rules) {\n    return null\n  }\n  const styleSheetCssText = Array.from(rules, isSafari() ? getCssRuleStringForSafari : getCssRuleString).join('')\n  return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href)\n}\n\nfunction getCssRuleStringForSafari(rule: CSSRule): string {\n  // Safari does not escape attribute selectors containing : properly\n  // https://bugs.webkit.org/show_bug.cgi?id=184604\n  if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n    // This regex replaces [foo:bar] by [foo\\\\:bar]\n    const escapeColon = /(\\[[\\w-]+[^\\\\])(:[^\\]]+\\])/g\n    return rule.cssText.replace(escapeColon, '$1\\\\$2')\n  }\n\n  return getCssRuleString(rule)\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  // If it's an @import rule, try to inline sub-rules recursively with `getCssRulesString`. This\n  // operation can fail if the imported stylesheet is protected by CORS, in which case we fallback\n  // to the @import rule CSS text.\n  return (isCSSImportRule(rule) && getCssRulesString(rule.styleSheet)) || rule.cssText\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule\n}\n\nfunction isCSSStyleRule(rule: CSSRule): rule is CSSStyleRule {\n  return 'selectorText' in rule\n}\n", "import {\n  reducePrivacyLevel,\n  getNodeSelfPrivacyLevel,\n  getTextContent,\n  isNodeShadowRoot,\n  hasChildNodes,\n  forEachChildNodes,\n  NodePrivacyLevel,\n  PRIVACY_ATTR_NAME,\n  PRIVACY_ATTR_VALUE_HIDDEN,\n} from '@datadog/browser-rum-core'\nimport type {\n  DocumentFragmentNode,\n  DocumentNode,\n  SerializedNodeWithId,\n  CDataNode,\n  DocumentTypeNode,\n  ElementNode,\n  TextNode,\n} from '../../../types'\nimport { NodeType } from '../../../types'\nimport { getValidTagName } from './serializationUtils'\nimport type { ParentNodePrivacyLevel } from './serialization.types'\nimport { serializeStyleSheets } from './serializeStyleSheets'\nimport { serializeAttributes } from './serializeAttributes'\nimport type { SerializationTransaction } from './serializationTransaction'\n\nexport function serializeNode(\n  node: Element,\n  parentNodePrivacyLevel: ParentNodePrivacyLevel,\n  transaction: SerializationTransaction\n): (SerializedNodeWithId & ElementNode) | null\nexport function serializeNode(\n  node: Node,\n  parentNodePrivacyLevel: ParentNodePrivacyLevel,\n  transaction: SerializationTransaction\n): SerializedNodeWithId | null\nexport function serializeNode(\n  node: Node,\n  parentNodePrivacyLevel: ParentNodePrivacyLevel,\n  transaction: SerializationTransaction\n): SerializedNodeWithId | null {\n  switch (node.nodeType) {\n    case node.DOCUMENT_NODE:\n      return serializeDocumentNode(node as Document, parentNodePrivacyLevel, transaction)\n    case node.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragmentNode(node as DocumentFragment, parentNodePrivacyLevel, transaction)\n    case node.DOCUMENT_TYPE_NODE:\n      return serializeDocumentTypeNode(node as DocumentType, transaction)\n    case node.ELEMENT_NODE:\n      return serializeElementNode(node as Element, parentNodePrivacyLevel, transaction)\n    case node.TEXT_NODE:\n      return serializeTextNode(node as Text, parentNodePrivacyLevel, transaction)\n    case node.CDATA_SECTION_NODE:\n      return serializeCDataNode(node as CDATASection, transaction)\n    default:\n      return null\n  }\n}\n\nexport function serializeChildNodes(\n  node: Node,\n  parentNodePrivacyLevel: ParentNodePrivacyLevel,\n  transaction: SerializationTransaction\n): SerializedNodeWithId[] {\n  const result: SerializedNodeWithId[] = []\n  forEachChildNodes(node, (childNode) => {\n    const serializedChildNode = serializeNode(childNode, parentNodePrivacyLevel, transaction)\n    if (serializedChildNode) {\n      result.push(serializedChildNode)\n    }\n  })\n  return result\n}\n\nexport function serializeDocumentNode(\n  document: Document,\n  parentNodePrivacyLevel: ParentNodePrivacyLevel,\n  transaction: SerializationTransaction\n): DocumentNode & SerializedNodeWithId {\n  return {\n    type: NodeType.Document,\n    id: transaction.assignId(document),\n    childNodes: serializeChildNodes(document, parentNodePrivacyLevel, transaction),\n    adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets),\n  }\n}\n\nfunction serializeDocumentFragmentNode(\n  element: DocumentFragment,\n  parentNodePrivacyLevel: ParentNodePrivacyLevel,\n  transaction: SerializationTransaction\n): DocumentFragmentNode & SerializedNodeWithId {\n  const isShadowRoot = isNodeShadowRoot(element)\n  if (isShadowRoot) {\n    transaction.scope.shadowRootsController.addShadowRoot(element, transaction.scope)\n  }\n\n  return {\n    type: NodeType.DocumentFragment,\n    id: transaction.assignId(element),\n    childNodes: serializeChildNodes(element, parentNodePrivacyLevel, transaction),\n    isShadowRoot,\n    adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined,\n  }\n}\n\nfunction serializeDocumentTypeNode(\n  documentType: DocumentType,\n  transaction: SerializationTransaction\n): DocumentTypeNode & SerializedNodeWithId {\n  return {\n    type: NodeType.DocumentType,\n    id: transaction.assignId(documentType),\n    name: documentType.name,\n    publicId: documentType.publicId,\n    systemId: documentType.systemId,\n  }\n}\n\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\n\nfunction serializeElementNode(\n  element: Element,\n  parentNodePrivacyLevel: ParentNodePrivacyLevel,\n  transaction: SerializationTransaction\n): (ElementNode & SerializedNodeWithId) | null {\n  const tagName = getValidTagName(element.tagName)\n  const isSVG = isSVGElement(element) || undefined\n\n  // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n  // parentNodePrivacyLevel option to avoid iterating over all parents\n  const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), parentNodePrivacyLevel)\n\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    const { width, height } = element.getBoundingClientRect()\n    return {\n      type: NodeType.Element,\n      id: transaction.assignId(element),\n      tagName,\n      attributes: {\n        rr_width: `${width}px`,\n        rr_height: `${height}px`,\n        [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,\n      },\n      childNodes: [],\n      isSVG,\n    }\n  }\n\n  // Ignore Elements like Script and some Link, Metas\n  if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n    return null\n  }\n\n  const id = transaction.assignId(element)\n  const attributes = serializeAttributes(element, nodePrivacyLevel, transaction)\n\n  let childNodes: SerializedNodeWithId[] = []\n  if (\n    hasChildNodes(element) &&\n    // Do not serialize style children as the css rules are already in the _cssText attribute\n    tagName !== 'style'\n  ) {\n    childNodes = serializeChildNodes(element, nodePrivacyLevel, transaction)\n  }\n\n  return {\n    type: NodeType.Element,\n    id,\n    tagName,\n    attributes,\n    childNodes,\n    isSVG,\n  }\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement\n}\n\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\n\nfunction serializeTextNode(\n  textNode: Text,\n  parentNodePrivacyLevel: ParentNodePrivacyLevel,\n  transaction: SerializationTransaction\n): (TextNode & SerializedNodeWithId) | null {\n  const textContent = getTextContent(textNode, parentNodePrivacyLevel)\n  if (textContent === undefined) {\n    return null\n  }\n  return {\n    type: NodeType.Text,\n    id: transaction.assignId(textNode),\n    textContent,\n  }\n}\n\nfunction serializeCDataNode(\n  node: CDATASection,\n  transaction: SerializationTransaction\n): CDataNode & SerializedNodeWithId {\n  return {\n    type: NodeType.CDATA,\n    id: transaction.assignId(node),\n    textContent: '',\n  }\n}\n", "import type { DocumentNode, SerializedNodeWithId } from '../../../types'\nimport { serializeNode } from './serializeNode'\nimport type { SerializationTransaction } from './serializationTransaction'\n\nexport function serializeDocument(\n  document: Document,\n  transaction: SerializationTransaction\n): DocumentNode & SerializedNodeWithId {\n  const defaultPrivacyLevel = transaction.scope.configuration.defaultPrivacyLevel\n  const serializedNode = serializeNode(document, defaultPrivacyLevel, transaction)\n\n  // We are sure that Documents are never ignored, so this function never returns null\n  return serializedNode as DocumentNode & SerializedNodeWithId\n}\n", "export interface SerializationMetric {\n  count: number\n  max: number\n  sum: number\n}\n\nexport interface SerializationStats {\n  cssText: SerializationMetric\n  serializationDuration: SerializationMetric\n}\n\nexport function createSerializationStats(): SerializationStats {\n  return {\n    cssText: {\n      count: 0,\n      max: 0,\n      sum: 0,\n    },\n    serializationDuration: {\n      count: 0,\n      max: 0,\n      sum: 0,\n    },\n  }\n}\n\nexport function updateSerializationStats(\n  stats: SerializationStats,\n  metric: keyof SerializationStats,\n  value: number\n): void {\n  stats[metric].count += 1\n  stats[metric].max = Math.max(stats[metric].max, value)\n  stats[metric].sum += value\n}\n\nexport function aggregateSerializationStats(aggregateStats: SerializationStats, stats: SerializationStats) {\n  for (const metric of ['cssText', 'serializationDuration'] as const) {\n    aggregateStats[metric].count += stats[metric].count\n    aggregateStats[metric].max = Math.max(aggregateStats[metric].max, stats[metric].max)\n    aggregateStats[metric].sum += stats[metric].sum\n  }\n}\n", "import { elapsed, timeStampNow } from '@datadog/browser-core'\n\nimport type { BrowserRecord } from '../../../types'\nimport type { NodeId } from '../itemIds'\nimport type { EmitRecordCallback, EmitStatsCallback } from '../record.types'\nimport type { RecordingScope } from '../recordingScope'\nimport type { SerializationStats } from './serializationStats'\nimport { createSerializationStats, updateSerializationStats } from './serializationStats'\n\nexport type SerializationTransactionCallback = (transaction: SerializationTransaction) => void\n\nexport const enum SerializationKind {\n  INITIAL_FULL_SNAPSHOT,\n  SUBSEQUENT_FULL_SNAPSHOT,\n  INCREMENTAL_SNAPSHOT,\n}\n\n/**\n * A serialization transaction is used to build and emit a sequence of session replay\n * records containing a serialized snapshot of the DOM.\n */\nexport interface SerializationTransaction {\n  /** Add a record to the transaction. It will be emitted when the transaction ends. */\n  add(record: BrowserRecord): void\n\n  /**\n   * Add a metric to the transaction's statistics. The aggregated statistics will be\n   * emitted when the transaction ends.\n   */\n  addMetric(metric: keyof SerializationStats, value: number): void\n\n  /**\n   * Assign and return an id to the given node. If the node has previously been assigned\n   * an id, the existing id will be reused.\n   */\n  assignId(node: Node): NodeId\n\n  /** The kind of serialization being performed in this transaction. */\n  kind: SerializationKind\n\n  /**\n   * A set used to track nodes which have been serialized in the current transaction. If\n   * undefined, this feature is disabled; this is the default state in new transactions\n   * for performance reasons. Set the property to a non-undefined value if you need this\n   * capability.\n   */\n  serializedNodeIds?: Set<NodeId>\n\n  /** The recording scope in which this transaction is occurring. */\n  scope: RecordingScope\n}\n\n/**\n * Perform serialization within a transaction. At the end of the transaction, the\n * generated records and statistics will be emitted.\n */\nexport function serializeInTransaction(\n  kind: SerializationKind,\n  emitRecord: EmitRecordCallback,\n  emitStats: EmitStatsCallback,\n  scope: RecordingScope,\n  serialize: SerializationTransactionCallback\n): void {\n  const records: BrowserRecord[] = []\n  const stats = createSerializationStats()\n\n  const transaction: SerializationTransaction = {\n    add(record: BrowserRecord): void {\n      records.push(record)\n    },\n    addMetric(metric: keyof SerializationStats, value: number): void {\n      updateSerializationStats(stats, metric, value)\n    },\n    assignId(node: Node): NodeId {\n      const id = scope.nodeIds.getOrInsert(node)\n      if (transaction.serializedNodeIds) {\n        transaction.serializedNodeIds.add(id)\n      }\n      return id\n    },\n    kind,\n    scope,\n  }\n\n  const start = timeStampNow()\n  serialize(transaction)\n  updateSerializationStats(stats, 'serializationDuration', elapsed(start, timeStampNow()))\n\n  for (const record of records) {\n    emitRecord(record)\n  }\n\n  emitStats(stats)\n}\n", "/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n\nimport type { VisualViewportRecord } from '../../types'\n\n// Scrollbar widths vary across properties on different devices and browsers\nconst TOLERANCE = 25\n\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn(visualViewport: VisualViewport) {\n  return (\n    Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE ||\n    Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE\n  )\n}\n\ninterface LayoutCoordinates {\n  layoutViewportX: number\n  layoutViewportY: number\n  visualViewportX: number\n  visualViewportY: number\n}\n\nexport const convertMouseEventToLayoutCoordinates = (clientX: number, clientY: number): LayoutCoordinates => {\n  const visualViewport = window.visualViewport\n  const normalized: LayoutCoordinates = {\n    layoutViewportX: clientX,\n    layoutViewportY: clientY,\n    visualViewportX: clientX,\n    visualViewportY: clientY,\n  }\n\n  if (!visualViewport) {\n    // On old browsers, we cannot normalize, so fallback to clientX/Y\n    return normalized\n  } else if (isVisualViewportFactoredIn(visualViewport)) {\n    // Typically Mobile Devices\n    normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft)\n    normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop)\n  } else {\n    // Typically Desktop Devices\n    normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft)\n    normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop)\n  }\n  return normalized\n}\n\nexport const getVisualViewport = (visualViewport: VisualViewport): VisualViewportRecord['data'] => ({\n  scale: visualViewport.scale,\n  offsetLeft: visualViewport.offsetLeft,\n  offsetTop: visualViewport.offsetTop,\n  pageLeft: visualViewport.pageLeft,\n  pageTop: visualViewport.pageTop,\n  height: visualViewport.height,\n  width: visualViewport.width,\n})\n", "import { LifeCycleEventType, getScrollX, getScrollY, getViewportDimension } from '@datadog/browser-rum-core'\nimport type { LifeCycle } from '@datadog/browser-rum-core'\nimport { timeStampNow } from '@datadog/browser-core'\nimport type { TimeStamp } from '@datadog/browser-core'\nimport { RecordType } from '../../types'\nimport type { SerializationTransaction } from './serialization'\nimport { serializeDocument, serializeInTransaction, SerializationKind } from './serialization'\nimport { getVisualViewport } from './viewports'\nimport type { RecordingScope } from './recordingScope'\nimport type { EmitRecordCallback, EmitStatsCallback } from './record.types'\n\nexport function startFullSnapshots(\n  lifeCycle: LifeCycle,\n  emitRecord: EmitRecordCallback,\n  emitStats: EmitStatsCallback,\n  flushMutations: () => void,\n  scope: RecordingScope\n) {\n  takeFullSnapshot(timeStampNow(), SerializationKind.INITIAL_FULL_SNAPSHOT, emitRecord, emitStats, scope)\n\n  const { unsubscribe } = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, (view) => {\n    flushMutations()\n    takeFullSnapshot(\n      view.startClocks.timeStamp,\n      SerializationKind.SUBSEQUENT_FULL_SNAPSHOT,\n      emitRecord,\n      emitStats,\n      scope\n    )\n  })\n\n  return {\n    stop: unsubscribe,\n  }\n}\n\nexport function takeFullSnapshot(\n  timestamp: TimeStamp,\n  kind: SerializationKind,\n  emitRecord: EmitRecordCallback,\n  emitStats: EmitStatsCallback,\n  scope: RecordingScope\n): void {\n  serializeInTransaction(kind, emitRecord, emitStats, scope, (transaction: SerializationTransaction): void => {\n    const { width, height } = getViewportDimension()\n    transaction.add({\n      data: {\n        height,\n        href: window.location.href,\n        width,\n      },\n      type: RecordType.Meta,\n      timestamp,\n    })\n\n    transaction.add({\n      data: {\n        has_focus: document.hasFocus(),\n      },\n      type: RecordType.Focus,\n      timestamp,\n    })\n\n    transaction.add({\n      data: {\n        node: serializeDocument(document, transaction),\n        initialOffset: {\n          left: getScrollX(),\n          top: getScrollY(),\n        },\n      },\n      type: RecordType.FullSnapshot,\n      timestamp,\n    })\n\n    if (window.visualViewport) {\n      transaction.add({\n        data: getVisualViewport(window.visualViewport),\n        type: RecordType.VisualViewport,\n        timestamp,\n      })\n    }\n  })\n}\n", "export type EventId = number & { __brand: 'EventId' }\nexport type EventIds = ItemIds<Event, EventId>\nexport const enum EventIdConstants {\n  FIRST_ID = 1,\n}\nexport function createEventIds(): EventIds {\n  return createWeakIdMap(EventIdConstants.FIRST_ID as EventId)\n}\n\nexport type NodeId = number & { __brand: 'NodeId' }\nexport type NodeIds = ItemIds<Node, NodeId>\nexport const enum NodeIdConstants {\n  FIRST_ID = 0,\n}\nexport function createNodeIds(): NodeIds {\n  return createWeakIdMap(NodeIdConstants.FIRST_ID as NodeId)\n}\n\nexport type StringId = number & { __brand: 'StringId' }\nexport type StringIds = ItemIds<string, StringId>\nexport const enum StringIdConstants {\n  FIRST_ID = 0,\n}\nexport function createStringIds(): StringIds {\n  return createIdMap(StringIdConstants.FIRST_ID as StringId)\n}\n\nexport type StyleSheetId = number & { __brand: 'StyleSheetId' }\nexport type StyleSheetIds = ItemIds<CSSStyleSheet, StyleSheetId>\nexport const enum StyleSheetIdConstants {\n  FIRST_ID = 0,\n}\nexport function createStyleSheetIds(): StyleSheetIds {\n  return createWeakIdMap(StyleSheetIdConstants.FIRST_ID as StyleSheetId)\n}\n\nexport interface ItemIds<ItemType, ItemId extends number> {\n  clear(this: void): void\n  get(this: void, item: ItemType): ItemId | undefined\n  getOrInsert(this: void, item: ItemType): ItemId\n  get size(): number\n}\n\nfunction createIdMap<ItemType, ItemId extends number>(firstId: ItemId): ItemIds<ItemType, ItemId> {\n  return createItemIds(() => new Map<ItemType, ItemId>(), firstId)\n}\n\nfunction createWeakIdMap<ItemType extends object, ItemId extends number>(firstId: ItemId): ItemIds<ItemType, ItemId> {\n  return createItemIds(() => new WeakMap<ItemType, ItemId>(), firstId)\n}\n\ninterface MapLike<Key, Value> {\n  get(key: Key): Value | undefined\n  set(key: Key, value: Value): void\n}\n\nfunction createItemIds<ItemType, ItemId extends number>(\n  createMap: () => MapLike<ItemType, ItemId>,\n  firstId: ItemId\n): ItemIds<ItemType, ItemId> {\n  let map = createMap()\n  let nextId = firstId\n\n  const get = (object: ItemType): ItemId | undefined => map.get(object)\n\n  return {\n    clear(): void {\n      map = createMap()\n      nextId = firstId\n    },\n    get,\n    getOrInsert(object: ItemType): ItemId {\n      // Try to reuse any existing id.\n      let id = get(object)\n      if (id === undefined) {\n        id = nextId++ as ItemId\n        map.set(object, id)\n      }\n      return id\n    },\n    get size(): number {\n      return nextId - firstId\n    },\n  }\n}\n", "import type { RumConfiguration } from '@datadog/browser-rum-core'\n\nimport type { ElementsScrollPositions } from './elementsScrollPositions'\nimport { createEventIds, createNodeIds, createStringIds, createStyleSheetIds } from './itemIds'\nimport type { EventIds, NodeIds, StringIds, StyleSheetIds } from './itemIds'\nimport type { ShadowRootsController } from './shadowRootsController'\n\n/**\n * State associated with a stream of session replay records. When a new stream of records\n * starts (e.g. because recording has shut down and restarted), a new RecordingScope\n * object must be created; this ensures that we don't generate records that reference ids\n * or data which aren't present in the current stream.\n */\nexport interface RecordingScope {\n  configuration: RumConfiguration\n  elementsScrollPositions: ElementsScrollPositions\n  eventIds: EventIds\n  nodeIds: NodeIds\n  shadowRootsController: ShadowRootsController\n  stringIds: StringIds\n  styleSheetIds: StyleSheetIds\n}\n\nexport function createRecordingScope(\n  configuration: RumConfiguration,\n  elementsScrollPositions: ElementsScrollPositions,\n  shadowRootsController: ShadowRootsController\n): RecordingScope {\n  const eventIds = createEventIds()\n  const nodeIds = createNodeIds()\n  const stringIds = createStringIds()\n  const styleSheetIds = createStyleSheetIds()\n  return {\n    configuration,\n    elementsScrollPositions,\n    eventIds,\n    nodeIds,\n    shadowRootsController,\n    stringIds,\n    styleSheetIds,\n  }\n}\n", "export type ElementsScrollPositions = ReturnType<typeof createElementsScrollPositions>\nexport interface ScrollPositions {\n  scrollLeft: number\n  scrollTop: number\n}\n\nexport function createElementsScrollPositions() {\n  const scrollPositionsByElement = new WeakMap<Element, ScrollPositions>()\n  return {\n    set(element: Element | Document, scrollPositions: ScrollPositions) {\n      if (element === document && !document.scrollingElement) {\n        // cf https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement,\n        // in some cases scrolling elements can not be defined, we don't support those for now\n        return\n      }\n      scrollPositionsByElement.set(\n        element === document ? document.scrollingElement! : (element as Element),\n        scrollPositions\n      )\n    },\n    get(element: Element) {\n      return scrollPositionsByElement.get(element)\n    },\n    has(element: Element) {\n      return scrollPositionsByElement.has(element)\n    },\n  }\n}\n", "import { isNodeShadowHost } from '@datadog/browser-rum-core'\n\nexport function isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches)\n}\n\nexport function getEventTarget(event: Event): Node {\n  if (event.composed === true && isNodeShadowHost(event.target as Node)) {\n    return event.composedPath()[0] as Node\n  }\n  return event.target as Node\n}\n", "import { timeStampNow } from '@datadog/browser-core'\nimport type { BrowserIncrementalData, BrowserIncrementalSnapshotRecord } from '../../types'\nimport { RecordType } from '../../types'\n\nexport function assembleIncrementalSnapshot<Data extends BrowserIncrementalData>(\n  source: Data['source'],\n  data: Omit<Data, 'source'>\n): BrowserIncrementalSnapshotRecord {\n  return {\n    data: {\n      source,\n      ...data,\n    } as Data,\n    type: RecordType.IncrementalSnapshot,\n    timestamp: timeStampNow(),\n  }\n}\n", "import { addEventListeners, DOM_EVENT, throttle } from '@datadog/browser-core'\nimport type { BrowserIncrementalSnapshotRecord, MousemoveData, MousePosition } from '../../../types'\nimport { IncrementalSource } from '../../../types'\nimport { getEventTarget, isTouchEvent } from '../eventsUtils'\nimport { convertMouseEventToLayoutCoordinates } from '../viewports'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { RecordingScope } from '../recordingScope'\nimport type { EmitRecordCallback } from '../record.types'\nimport type { Tracker } from './tracker.types'\n\nconst MOUSE_MOVE_OBSERVER_THRESHOLD = 50\n\nexport function trackMove(\n  emitRecord: EmitRecordCallback<BrowserIncrementalSnapshotRecord>,\n  scope: RecordingScope\n): Tracker {\n  const { throttled: updatePosition, cancel: cancelThrottle } = throttle(\n    (event: MouseEvent | TouchEvent) => {\n      const target = getEventTarget(event)\n      const id = scope.nodeIds.get(target)\n      if (id === undefined) {\n        return\n      }\n      const coordinates = tryToComputeCoordinates(event)\n      if (!coordinates) {\n        return\n      }\n      const position: MousePosition = {\n        id,\n        timeOffset: 0,\n        x: coordinates.x,\n        y: coordinates.y,\n      }\n\n      emitRecord(\n        assembleIncrementalSnapshot<MousemoveData>(\n          isTouchEvent(event) ? IncrementalSource.TouchMove : IncrementalSource.MouseMove,\n          { positions: [position] }\n        )\n      )\n    },\n    MOUSE_MOVE_OBSERVER_THRESHOLD,\n    {\n      trailing: false,\n    }\n  )\n\n  const { stop: removeListener } = addEventListeners(\n    scope.configuration,\n    document,\n    [DOM_EVENT.MOUSE_MOVE, DOM_EVENT.TOUCH_MOVE],\n    updatePosition,\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  return {\n    stop: () => {\n      removeListener()\n      cancelThrottle()\n    },\n  }\n}\n\nexport function tryToComputeCoordinates(event: MouseEvent | TouchEvent) {\n  let { clientX: x, clientY: y } = isTouchEvent(event) ? event.changedTouches[0] : event\n  if (window.visualViewport) {\n    const { visualViewportX, visualViewportY } = convertMouseEventToLayoutCoordinates(x, y)\n    x = visualViewportX\n    y = visualViewportY\n  }\n  if (!Number.isFinite(x) || !Number.isFinite(y)) {\n    return undefined\n  }\n  return { x, y }\n}\n", "import { addEventListeners, DOM_EVENT } from '@datadog/browser-core'\nimport { getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core'\nimport type { MouseInteraction, MouseInteractionData, BrowserIncrementalSnapshotRecord } from '../../../types'\nimport { IncrementalSource, MouseInteractionType } from '../../../types'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport { getEventTarget } from '../eventsUtils'\nimport type { RecordingScope } from '../recordingScope'\nimport type { EmitRecordCallback } from '../record.types'\nimport { tryToComputeCoordinates } from './trackMove'\nimport type { Tracker } from './tracker.types'\n\nconst eventTypeToMouseInteraction = {\n  // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This\n  // allows to reference such records from Frustration records.\n  //\n  // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records\n  // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace\n  // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to\n  // convey such interaction. This would cleanly solve the issue since we would have\n  // `PointerInteraction/Up` records that we could reference from `Frustration` records.\n  [DOM_EVENT.POINTER_UP]: MouseInteractionType.MouseUp,\n\n  [DOM_EVENT.MOUSE_DOWN]: MouseInteractionType.MouseDown,\n  [DOM_EVENT.CLICK]: MouseInteractionType.Click,\n  [DOM_EVENT.CONTEXT_MENU]: MouseInteractionType.ContextMenu,\n  [DOM_EVENT.DBL_CLICK]: MouseInteractionType.DblClick,\n  [DOM_EVENT.FOCUS]: MouseInteractionType.Focus,\n  [DOM_EVENT.BLUR]: MouseInteractionType.Blur,\n  [DOM_EVENT.TOUCH_START]: MouseInteractionType.TouchStart,\n  [DOM_EVENT.TOUCH_END]: MouseInteractionType.TouchEnd,\n}\n\nexport function trackMouseInteraction(\n  emitRecord: EmitRecordCallback<BrowserIncrementalSnapshotRecord>,\n  scope: RecordingScope\n): Tracker {\n  const handler = (event: MouseEvent | TouchEvent | FocusEvent) => {\n    const target = getEventTarget(event)\n    const id = scope.nodeIds.get(target)\n    if (\n      id === undefined ||\n      getNodePrivacyLevel(target, scope.configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN\n    ) {\n      return\n    }\n    const type = eventTypeToMouseInteraction[event.type as keyof typeof eventTypeToMouseInteraction]\n\n    let interaction: MouseInteraction\n    if (type !== MouseInteractionType.Blur && type !== MouseInteractionType.Focus) {\n      const coordinates = tryToComputeCoordinates(event as MouseEvent | TouchEvent)\n      if (!coordinates) {\n        return\n      }\n      interaction = { id, type, x: coordinates.x, y: coordinates.y }\n    } else {\n      interaction = { id, type }\n    }\n\n    emitRecord({\n      id: scope.eventIds.getOrInsert(event),\n      ...assembleIncrementalSnapshot<MouseInteractionData>(IncrementalSource.MouseInteraction, interaction),\n    })\n  }\n  return addEventListeners(\n    scope.configuration,\n    document,\n    Object.keys(eventTypeToMouseInteraction) as Array<keyof typeof eventTypeToMouseInteraction>,\n    handler,\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n}\n", "import { DOM_EVENT, throttle, addEventListener } from '@datadog/browser-core'\nimport { getScrollX, getScrollY, getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core'\nimport { getEventTarget } from '../eventsUtils'\nimport { IncrementalSource } from '../../../types'\nimport type { BrowserIncrementalSnapshotRecord, ScrollData } from '../../../types'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { RecordingScope } from '../recordingScope'\nimport type { EmitRecordCallback } from '../record.types'\nimport type { Tracker } from './tracker.types'\n\nconst SCROLL_OBSERVER_THRESHOLD = 100\n\nexport function trackScroll(\n  target: Document | ShadowRoot,\n  emitRecord: EmitRecordCallback<BrowserIncrementalSnapshotRecord>,\n  scope: RecordingScope\n): Tracker {\n  const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event: Event) => {\n    const target = getEventTarget(event) as HTMLElement | Document\n    if (!target) {\n      return\n    }\n    const id = scope.nodeIds.get(target)\n    if (\n      id === undefined ||\n      getNodePrivacyLevel(target, scope.configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN\n    ) {\n      return\n    }\n    const scrollPositions =\n      target === document\n        ? {\n            scrollTop: getScrollY(),\n            scrollLeft: getScrollX(),\n          }\n        : {\n            scrollTop: Math.round((target as HTMLElement).scrollTop),\n            scrollLeft: Math.round((target as HTMLElement).scrollLeft),\n          }\n    scope.elementsScrollPositions.set(target, scrollPositions)\n    emitRecord(\n      assembleIncrementalSnapshot<ScrollData>(IncrementalSource.Scroll, {\n        id,\n        x: scrollPositions.scrollLeft,\n        y: scrollPositions.scrollTop,\n      })\n    )\n  }, SCROLL_OBSERVER_THRESHOLD)\n\n  const { stop: removeListener } = addEventListener(scope.configuration, target, DOM_EVENT.SCROLL, updatePosition, {\n    capture: true,\n    passive: true,\n  })\n\n  return {\n    stop: () => {\n      removeListener()\n      cancelThrottle()\n    },\n  }\n}\n", "import { throttle, DOM_EVENT, addEventListeners, timeStampNow, noop } from '@datadog/browser-core'\nimport type { ViewportDimension } from '@datadog/browser-rum-core'\nimport { initViewportObservable } from '@datadog/browser-rum-core'\nimport { IncrementalSource, RecordType } from '../../../types'\nimport type { BrowserIncrementalSnapshotRecord, ViewportResizeData, VisualViewportRecord } from '../../../types'\nimport { getVisualViewport } from '../viewports'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { EmitRecordCallback } from '../record.types'\nimport type { RecordingScope } from '../recordingScope'\nimport type { Tracker } from './tracker.types'\n\nconst VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200\n\nexport function trackViewportResize(\n  emitRecord: EmitRecordCallback<BrowserIncrementalSnapshotRecord>,\n  scope: RecordingScope\n): Tracker {\n  const viewportResizeSubscription = initViewportObservable(scope.configuration).subscribe(\n    (data: ViewportDimension) => {\n      emitRecord(assembleIncrementalSnapshot<ViewportResizeData>(IncrementalSource.ViewportResize, data))\n    }\n  )\n\n  return {\n    stop: () => {\n      viewportResizeSubscription.unsubscribe()\n    },\n  }\n}\n\nexport function trackVisualViewportResize(\n  emitRecord: EmitRecordCallback<VisualViewportRecord>,\n  scope: RecordingScope\n): Tracker {\n  const visualViewport = window.visualViewport\n  if (!visualViewport) {\n    return { stop: noop }\n  }\n  const { throttled: updateDimension, cancel: cancelThrottle } = throttle(\n    () => {\n      emitRecord({\n        data: getVisualViewport(visualViewport),\n        type: RecordType.VisualViewport,\n        timestamp: timeStampNow(),\n      })\n    },\n    VISUAL_VIEWPORT_OBSERVER_THRESHOLD,\n    {\n      trailing: false,\n    }\n  )\n  const { stop: removeListener } = addEventListeners(\n    scope.configuration,\n    visualViewport,\n    [DOM_EVENT.RESIZE, DOM_EVENT.SCROLL],\n    updateDimension,\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  return {\n    stop: () => {\n      removeListener()\n      cancelThrottle()\n    },\n  }\n}\n", "import { DOM_EVENT, addEventListeners } from '@datadog/browser-core'\nimport { NodePrivacyLevel, getNodePrivacyLevel } from '@datadog/browser-rum-core'\nimport type { MediaInteractionData, BrowserIncrementalSnapshotRecord } from '../../../types'\nimport { IncrementalSource, MediaInteractionType } from '../../../types'\nimport { getEventTarget } from '../eventsUtils'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { EmitRecordCallback } from '../record.types'\nimport type { RecordingScope } from '../recordingScope'\nimport type { Tracker } from './tracker.types'\n\nexport function trackMediaInteraction(\n  emitRecord: EmitRecordCallback<BrowserIncrementalSnapshotRecord>,\n  scope: RecordingScope\n): Tracker {\n  return addEventListeners(\n    scope.configuration,\n    document,\n    [DOM_EVENT.PLAY, DOM_EVENT.PAUSE],\n    (event) => {\n      const target = getEventTarget(event)\n      if (!target) {\n        return\n      }\n      const id = scope.nodeIds.get(target)\n      if (\n        id === undefined ||\n        getNodePrivacyLevel(target, scope.configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN\n      ) {\n        return\n      }\n      emitRecord(\n        assembleIncrementalSnapshot<MediaInteractionData>(IncrementalSource.MediaInteraction, {\n          id,\n          type: event.type === DOM_EVENT.PLAY ? MediaInteractionType.Play : MediaInteractionType.Pause,\n        })\n      )\n    },\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n}\n", "import { instrumentMethod } from '@datadog/browser-core'\nimport { IncrementalSource } from '../../../types'\nimport type { BrowserIncrementalSnapshotRecord, StyleSheetRuleData } from '../../../types'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { RecordingScope } from '../recordingScope'\nimport type { EmitRecordCallback } from '../record.types'\nimport type { Tracker } from './tracker.types'\n\ntype GroupingCSSRuleTypes = typeof CSSGroupingRule | typeof CSSMediaRule | typeof CSSSupportsRule\n\nexport function trackStyleSheet(\n  emitRecord: EmitRecordCallback<BrowserIncrementalSnapshotRecord>,\n  scope: RecordingScope\n): Tracker {\n  function checkStyleSheetAndCallback(styleSheet: CSSStyleSheet | null, callback: (id: number) => void): void {\n    if (!styleSheet || !styleSheet.ownerNode) {\n      return\n    }\n    const id = scope.nodeIds.get(styleSheet.ownerNode)\n    if (id === undefined) {\n      return\n    }\n    callback(id)\n  }\n\n  const instrumentationStoppers = [\n    instrumentMethod(CSSStyleSheet.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n      checkStyleSheetAndCallback(styleSheet, (id) =>\n        emitRecord(\n          assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n            id,\n            adds: [{ rule, index }],\n          })\n        )\n      )\n    }),\n\n    instrumentMethod(CSSStyleSheet.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n      checkStyleSheetAndCallback(styleSheet, (id) =>\n        emitRecord(\n          assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n            id,\n            removes: [{ index }],\n          })\n        )\n      )\n    }),\n  ]\n\n  if (typeof CSSGroupingRule !== 'undefined') {\n    instrumentGroupingCSSRuleClass(CSSGroupingRule)\n  } else {\n    instrumentGroupingCSSRuleClass(CSSMediaRule)\n    instrumentGroupingCSSRuleClass(CSSSupportsRule)\n  }\n\n  function instrumentGroupingCSSRuleClass(cls: GroupingCSSRuleTypes) {\n    instrumentationStoppers.push(\n      instrumentMethod(cls.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n        checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n          const path = getPathToNestedCSSRule(styleSheet)\n          if (path) {\n            path.push(index || 0)\n            emitRecord(\n              assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n                id,\n                adds: [{ rule, index: path }],\n              })\n            )\n          }\n        })\n      }),\n\n      instrumentMethod(cls.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n        checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n          const path = getPathToNestedCSSRule(styleSheet)\n          if (path) {\n            path.push(index)\n            emitRecord(\n              assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n                id,\n                removes: [{ index: path }],\n              })\n            )\n          }\n        })\n      })\n    )\n  }\n\n  return {\n    stop: () => {\n      instrumentationStoppers.forEach((stopper) => stopper.stop())\n    },\n  }\n}\n\nexport function getPathToNestedCSSRule(rule: CSSRule): number[] | undefined {\n  const path: number[] = []\n  let currentRule = rule\n  while (currentRule.parentRule) {\n    const rules = Array.from((currentRule.parentRule as CSSGroupingRule).cssRules)\n    const index = rules.indexOf(currentRule)\n    path.unshift(index)\n    currentRule = currentRule.parentRule\n  }\n  // A rule may not be attached to a stylesheet\n  if (!currentRule.parentStyleSheet) {\n    return\n  }\n\n  const rules = Array.from(currentRule.parentStyleSheet.cssRules)\n  const index = rules.indexOf(currentRule)\n  path.unshift(index)\n\n  return path\n}\n", "import { DOM_EVENT, addEventListeners, timeStampNow } from '@datadog/browser-core'\nimport type { FocusRecord } from '../../../types'\nimport { RecordType } from '../../../types'\nimport type { RecordingScope } from '../recordingScope'\nimport type { EmitRecordCallback } from '../record.types'\nimport type { Tracker } from './tracker.types'\n\nexport function trackFocus(emitRecord: EmitRecordCallback<FocusRecord>, scope: RecordingScope): Tracker {\n  return addEventListeners(scope.configuration, window, [DOM_EVENT.FOCUS, DOM_EVENT.BLUR], () => {\n    emitRecord({\n      data: { has_focus: document.hasFocus() },\n      type: RecordType.Focus,\n      timestamp: timeStampNow(),\n    })\n  })\n}\n", "import type { LifeCycle } from '@datadog/browser-rum-core'\nimport { ActionType, RumEventType, LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { FrustrationRecord } from '../../../types'\nimport { RecordType } from '../../../types'\nimport type { EmitRecordCallback } from '../record.types'\nimport type { RecordingScope } from '../recordingScope'\nimport type { Tracker } from './tracker.types'\n\nexport function trackFrustration(\n  lifeCycle: LifeCycle,\n  emitRecord: EmitRecordCallback<FrustrationRecord>,\n  scope: RecordingScope\n): Tracker {\n  const frustrationSubscription = lifeCycle.subscribe(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, (data) => {\n    if (\n      data.rawRumEvent.type === RumEventType.ACTION &&\n      data.rawRumEvent.action.type === ActionType.CLICK &&\n      data.rawRumEvent.action.frustration?.type?.length &&\n      'events' in data.domainContext &&\n      data.domainContext.events &&\n      data.domainContext.events.length\n    ) {\n      emitRecord({\n        timestamp: data.rawRumEvent.date,\n        type: RecordType.FrustrationRecord,\n        data: {\n          frustrationTypes: data.rawRumEvent.action.frustration.type,\n          recordIds: data.domainContext.events.map((e) => scope.eventIds.getOrInsert(e)),\n        },\n      })\n    }\n  })\n\n  return {\n    stop: () => {\n      frustrationSubscription.unsubscribe()\n    },\n  }\n}\n", "import { timeStampNow } from '@datadog/browser-core'\nimport type { LifeCycle } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { ViewEndRecord } from '../../../types'\nimport { RecordType } from '../../../types'\nimport type { EmitRecordCallback } from '../record.types'\nimport type { Tracker } from './tracker.types'\n\nexport function trackViewEnd(\n  lifeCycle: LifeCycle,\n  emitRecord: EmitRecordCallback<ViewEndRecord>,\n  flushMutations: () => void\n): Tracker {\n  const viewEndSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, () => {\n    flushMutations()\n    emitRecord({\n      timestamp: timeStampNow(),\n      type: RecordType.ViewEnd,\n    })\n  })\n\n  return {\n    stop: () => {\n      viewEndSubscription.unsubscribe()\n    },\n  }\n}\n", "import { instrumentSetter, DOM_EVENT, addEventListeners, noop } from '@datadog/browser-core'\nimport { NodePrivacyLevel, getNodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core'\nimport { IncrementalSource } from '../../../types'\nimport type { InputData, InputState } from '../../../types'\nimport { getEventTarget } from '../eventsUtils'\nimport type { RecordingScope } from '../recordingScope'\nimport { getElementInputValue } from '../serialization'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { EmitRecordCallback } from '../record.types'\nimport type { Tracker } from './tracker.types'\n\nexport function trackInput(\n  target: Document | ShadowRoot,\n  emitRecord: EmitRecordCallback,\n  scope: RecordingScope\n): Tracker {\n  const defaultPrivacyLevel = scope.configuration.defaultPrivacyLevel\n  const lastInputStateMap: WeakMap<Node, InputState> = new WeakMap()\n\n  const isShadowRoot = target !== document\n\n  const { stop: stopEventListeners } = addEventListeners(\n    scope.configuration,\n    target,\n    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow\n    // roots since it will be handled by the event listener that we did add to the document. Only\n    // the 'change' event is blocked and needs to be handled on shadow roots.\n    isShadowRoot ? [DOM_EVENT.CHANGE] : [DOM_EVENT.INPUT, DOM_EVENT.CHANGE],\n    (event) => {\n      const target = getEventTarget(event)\n      if (\n        target instanceof HTMLInputElement ||\n        target instanceof HTMLTextAreaElement ||\n        target instanceof HTMLSelectElement\n      ) {\n        onElementChange(target)\n      }\n    },\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  let stopPropertySetterInstrumentation: () => void\n  if (!isShadowRoot) {\n    const instrumentationStoppers = [\n      instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),\n      instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),\n    ]\n    stopPropertySetterInstrumentation = () => {\n      instrumentationStoppers.forEach((stopper) => stopper.stop())\n    }\n  } else {\n    stopPropertySetterInstrumentation = noop\n  }\n\n  return {\n    stop: () => {\n      stopPropertySetterInstrumentation()\n      stopEventListeners()\n    },\n  }\n\n  function onElementChange(target: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement) {\n    const nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel)\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n      return\n    }\n\n    const type = target.type\n\n    let inputState: InputState\n    if (type === 'radio' || type === 'checkbox') {\n      if (shouldMaskNode(target, nodePrivacyLevel)) {\n        return\n      }\n      inputState = { isChecked: (target as HTMLInputElement).checked }\n    } else {\n      const value = getElementInputValue(target, nodePrivacyLevel)\n      if (value === undefined) {\n        return\n      }\n      inputState = { text: value }\n    }\n\n    // Can be multiple changes on the same node within the same batched mutation observation.\n    createRecordIfStateChanged(target, inputState)\n\n    // If a radio was checked, other radios with the same name attribute will be unchecked.\n    const name = target.name\n    if (type === 'radio' && name && (target as HTMLInputElement).checked) {\n      document.querySelectorAll(`input[type=\"radio\"][name=\"${CSS.escape(name)}\"]`).forEach((el: Element) => {\n        if (el !== target) {\n          // TODO: Consider the privacy implications for various differing input privacy levels\n          createRecordIfStateChanged(el, { isChecked: false })\n        }\n      })\n    }\n  }\n\n  /**\n   * There can be multiple changes on the same node within the same batched mutation observation.\n   */\n  function createRecordIfStateChanged(target: Node, inputState: InputState) {\n    const id = scope.nodeIds.get(target)\n    if (id === undefined) {\n      return\n    }\n    const lastInputState = lastInputStateMap.get(target)\n    if (\n      !lastInputState ||\n      (lastInputState as { text?: string }).text !== (inputState as { text?: string }).text ||\n      (lastInputState as { isChecked?: boolean }).isChecked !== (inputState as { isChecked?: boolean }).isChecked\n    ) {\n      lastInputStateMap.set(target, inputState)\n      emitRecord(\n        assembleIncrementalSnapshot<InputData>(IncrementalSource.Input, {\n          id,\n          ...inputState,\n        })\n      )\n    }\n  }\n}\n", "import { noop, throttle, requestIdleCallback } from '@datadog/browser-core'\nimport type { RumMutationRecord } from '@datadog/browser-rum-core'\n\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nconst MUTATION_PROCESS_MAX_DELAY = 100\n/**\n * Minimum duration to wait before processing mutations. This is used to batch mutations together\n * and be able to deduplicate them to save processing time and bandwidth.\n * 16ms is the duration of a frame at 60fps that ensure fluid UI.\n */\nexport const MUTATION_PROCESS_MIN_DELAY = 16\n\nexport function createMutationBatch(processMutationBatch: (mutations: RumMutationRecord[]) => void) {\n  let cancelScheduledFlush = noop\n  let pendingMutations: RumMutationRecord[] = []\n\n  function flush() {\n    cancelScheduledFlush()\n    processMutationBatch(pendingMutations)\n    pendingMutations = []\n  }\n\n  const { throttled: throttledFlush, cancel: cancelThrottle } = throttle(flush, MUTATION_PROCESS_MIN_DELAY, {\n    leading: false,\n  })\n\n  return {\n    addMutations: (mutations: RumMutationRecord[]) => {\n      if (pendingMutations.length === 0) {\n        cancelScheduledFlush = requestIdleCallback(throttledFlush, { timeout: MUTATION_PROCESS_MAX_DELAY })\n      }\n      pendingMutations.push(...mutations)\n    },\n\n    flush,\n\n    stop: () => {\n      cancelScheduledFlush()\n      cancelThrottle()\n    },\n  }\n}\n", "import { monitor, noop } from '@datadog/browser-core'\nimport type {\n  NodePrivacyLevelCache,\n  RumMutationRecord,\n  RumChildListMutationRecord,\n  RumCharacterDataMutationRecord,\n  RumAttributesMutationRecord,\n} from '@datadog/browser-rum-core'\nimport {\n  isNodeShadowHost,\n  getMutationObserverConstructor,\n  getParentNode,\n  forEachChildNodes,\n  getNodePrivacyLevel,\n  getTextContent,\n  NodePrivacyLevel,\n  isNodeShadowRoot,\n} from '@datadog/browser-rum-core'\nimport { IncrementalSource } from '../../../types'\nimport type {\n  BrowserMutationData,\n  AddedNodeMutation,\n  AttributeMutation,\n  RemovedNodeMutation,\n  TextMutation,\n} from '../../../types'\nimport type { RecordingScope } from '../recordingScope'\nimport type { SerializationTransaction } from '../serialization'\nimport {\n  getElementInputValue,\n  serializeAttribute,\n  serializeInTransaction,\n  serializeNode,\n  SerializationKind,\n} from '../serialization'\nimport { createMutationBatch } from '../mutationBatch'\nimport type { RemoveShadowRootCallBack } from '../shadowRootsController'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { EmitRecordCallback, EmitStatsCallback } from '../record.types'\nimport type { NodeId, NodeIds } from '../itemIds'\nimport type { Tracker } from './tracker.types'\n\nexport type NodeWithSerializedNode = Node & { __brand: 'NodeWithSerializedNode' }\ntype WithSerializedTarget<T> = T & { target: NodeWithSerializedNode }\n\nexport type MutationTracker = Tracker & { flush: () => void }\n\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function trackMutation(\n  target: Node,\n  emitRecord: EmitRecordCallback,\n  emitStats: EmitStatsCallback,\n  scope: RecordingScope\n): MutationTracker {\n  const MutationObserver = getMutationObserverConstructor()\n  if (!MutationObserver) {\n    return { stop: noop, flush: noop }\n  }\n\n  const mutationBatch = createMutationBatch((mutations) => {\n    serializeInTransaction(\n      SerializationKind.INCREMENTAL_SNAPSHOT,\n      emitRecord,\n      emitStats,\n      scope,\n      (transaction: SerializationTransaction) =>\n        processMutations(mutations.concat(observer.takeRecords() as RumMutationRecord[]), transaction)\n    )\n  })\n\n  const observer = new MutationObserver(monitor(mutationBatch.addMutations) as (callback: RumMutationRecord[]) => void)\n\n  observer.observe(target, {\n    attributeOldValue: true,\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  })\n\n  return {\n    stop: () => {\n      observer.disconnect()\n      mutationBatch.stop()\n    },\n    flush: () => {\n      mutationBatch.flush()\n    },\n  }\n}\n\nfunction processMutations(mutations: RumMutationRecord[], transaction: SerializationTransaction): void {\n  const nodePrivacyLevelCache: NodePrivacyLevelCache = new Map()\n\n  mutations\n    .filter((mutation): mutation is RumChildListMutationRecord => mutation.type === 'childList')\n    .forEach((mutation) => {\n      mutation.removedNodes.forEach((removedNode) => {\n        traverseRemovedShadowDom(removedNode, transaction.scope.shadowRootsController.removeShadowRoot)\n      })\n    })\n\n  // Discard any mutation with a 'target' node that:\n  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n  // part of a mutation occurring in a parent Node\n  // * should be hidden or ignored\n  const filteredMutations = mutations.filter(\n    (mutation): mutation is WithSerializedTarget<RumMutationRecord> =>\n      mutation.target.isConnected &&\n      idsAreAssignedForNodeAndAncestors(mutation.target, transaction.scope.nodeIds) &&\n      getNodePrivacyLevel(\n        mutation.target,\n        transaction.scope.configuration.defaultPrivacyLevel,\n        nodePrivacyLevelCache\n      ) !== NodePrivacyLevel.HIDDEN\n  )\n\n  const { adds, removes, hasBeenSerialized } = processChildListMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumChildListMutationRecord> => mutation.type === 'childList'\n    ),\n    nodePrivacyLevelCache,\n    transaction\n  )\n\n  const texts = processCharacterDataMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumCharacterDataMutationRecord> =>\n        mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)\n    ),\n    nodePrivacyLevelCache,\n    transaction\n  )\n\n  const attributes = processAttributesMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumAttributesMutationRecord> =>\n        mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)\n    ),\n    nodePrivacyLevelCache,\n    transaction\n  )\n\n  if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n    return\n  }\n\n  transaction.add(\n    assembleIncrementalSnapshot<BrowserMutationData>(IncrementalSource.Mutation, {\n      adds,\n      removes,\n      texts,\n      attributes,\n    })\n  )\n}\n\nfunction processChildListMutations(\n  mutations: Array<WithSerializedTarget<RumChildListMutationRecord>>,\n  nodePrivacyLevelCache: NodePrivacyLevelCache,\n  transaction: SerializationTransaction\n) {\n  // First, we iterate over mutations to collect:\n  //\n  // * nodes that have been added in the document and not removed by a subsequent mutation\n  // * nodes that have been removed from the document but were not added in a previous mutation\n  //\n  // For this second category, we also collect their previous parent (mutation.target) because we'll\n  // need it to emit a 'remove' mutation.\n  //\n  // Those two categories may overlap: if a node moved from a position to another, it is reported as\n  // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n  // the node will be in both sets.\n  const addedAndMovedNodes = new Set<Node>()\n  const removedNodes = new Map<Node, NodeWithSerializedNode>()\n  for (const mutation of mutations) {\n    mutation.addedNodes.forEach((node) => {\n      addedAndMovedNodes.add(node)\n    })\n    mutation.removedNodes.forEach((node) => {\n      if (!addedAndMovedNodes.has(node)) {\n        removedNodes.set(node, mutation.target)\n      }\n      addedAndMovedNodes.delete(node)\n    })\n  }\n\n  // Then, we sort nodes that are still in the document by topological order, for two reasons:\n  //\n  // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n  // a precedent node.\n  //\n  // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n  // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n  // already serialized and have an id.\n  const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes)\n  sortAddedAndMovedNodes(sortedAddedAndMovedNodes)\n\n  // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n  // node ids in a set to be able to skip subsequent related mutations.\n  transaction.serializedNodeIds = new Set<NodeId>()\n\n  const addedNodeMutations: AddedNodeMutation[] = []\n  for (const node of sortedAddedAndMovedNodes) {\n    if (hasBeenSerialized(node)) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(\n      node.parentNode!,\n      transaction.scope.configuration.defaultPrivacyLevel,\n      nodePrivacyLevelCache\n    )\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    const serializedNode = serializeNode(node, parentNodePrivacyLevel, transaction)\n    if (!serializedNode) {\n      continue\n    }\n\n    const parentNode = getParentNode(node)!\n    addedNodeMutations.push({\n      nextId: getNextSibling(node),\n      parentId: transaction.scope.nodeIds.get(parentNode)!,\n      node: serializedNode,\n    })\n  }\n  // Finally, we emit remove mutations.\n  const removedNodeMutations: RemovedNodeMutation[] = []\n  removedNodes.forEach((parent, node) => {\n    const parentId = transaction.scope.nodeIds.get(parent)\n    const id = transaction.scope.nodeIds.get(node)\n    if (parentId !== undefined && id !== undefined) {\n      removedNodeMutations.push({ parentId, id })\n    }\n  })\n\n  return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized }\n\n  function hasBeenSerialized(node: Node) {\n    const id = transaction.scope.nodeIds.get(node)\n    return id !== undefined && transaction.serializedNodeIds?.has(id)\n  }\n\n  function getNextSibling(node: Node): null | number {\n    let nextSibling = node.nextSibling\n    while (nextSibling) {\n      const id = transaction.scope.nodeIds.get(nextSibling)\n      if (id !== undefined) {\n        return id\n      }\n      nextSibling = nextSibling.nextSibling\n    }\n\n    return null\n  }\n}\n\nfunction processCharacterDataMutations(\n  mutations: Array<WithSerializedTarget<RumCharacterDataMutationRecord>>,\n  nodePrivacyLevelCache: NodePrivacyLevelCache,\n  transaction: SerializationTransaction\n) {\n  const textMutations: TextMutation[] = []\n\n  // Deduplicate mutations based on their target node\n  const handledNodes = new Set<Node>()\n  const filteredMutations = mutations.filter((mutation) => {\n    if (handledNodes.has(mutation.target)) {\n      return false\n    }\n    handledNodes.add(mutation.target)\n    return true\n  })\n\n  // Emit mutations\n  for (const mutation of filteredMutations) {\n    const value = mutation.target.textContent\n    if (value === mutation.oldValue) {\n      continue\n    }\n\n    const id = transaction.scope.nodeIds.get(mutation.target)\n    if (id === undefined) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(\n      getParentNode(mutation.target)!,\n      transaction.scope.configuration.defaultPrivacyLevel,\n      nodePrivacyLevelCache\n    )\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    textMutations.push({\n      id,\n      value: getTextContent(mutation.target, parentNodePrivacyLevel) ?? null,\n    })\n  }\n\n  return textMutations\n}\n\nfunction processAttributesMutations(\n  mutations: Array<WithSerializedTarget<RumAttributesMutationRecord>>,\n  nodePrivacyLevelCache: NodePrivacyLevelCache,\n  transaction: SerializationTransaction\n) {\n  const attributeMutations: AttributeMutation[] = []\n\n  // Deduplicate mutations based on their target node and changed attribute\n  const handledElements = new Map<Element, Set<string>>()\n  const filteredMutations = mutations.filter((mutation) => {\n    const handledAttributes = handledElements.get(mutation.target)\n    if (handledAttributes && handledAttributes.has(mutation.attributeName!)) {\n      return false\n    }\n    if (!handledAttributes) {\n      handledElements.set(mutation.target, new Set([mutation.attributeName!]))\n    } else {\n      handledAttributes.add(mutation.attributeName!)\n    }\n    return true\n  })\n\n  // Emit mutations\n  const emittedMutations = new Map<Element, AttributeMutation>()\n  for (const mutation of filteredMutations) {\n    const uncensoredValue = mutation.target.getAttribute(mutation.attributeName!)\n    if (uncensoredValue === mutation.oldValue) {\n      continue\n    }\n\n    const id = transaction.scope.nodeIds.get(mutation.target)\n    if (id === undefined) {\n      continue\n    }\n\n    const privacyLevel = getNodePrivacyLevel(\n      mutation.target,\n      transaction.scope.configuration.defaultPrivacyLevel,\n      nodePrivacyLevelCache\n    )\n    const attributeValue = serializeAttribute(\n      mutation.target,\n      privacyLevel,\n      mutation.attributeName!,\n      transaction.scope.configuration\n    )\n\n    let transformedValue: string | null\n    if (mutation.attributeName === 'value') {\n      const inputValue = getElementInputValue(mutation.target, privacyLevel)\n      if (inputValue === undefined) {\n        continue\n      }\n      transformedValue = inputValue\n    } else if (typeof attributeValue === 'string') {\n      transformedValue = attributeValue\n    } else {\n      transformedValue = null\n    }\n\n    let emittedMutation = emittedMutations.get(mutation.target)\n    if (!emittedMutation) {\n      emittedMutation = { id, attributes: {} }\n      attributeMutations.push(emittedMutation)\n      emittedMutations.set(mutation.target, emittedMutation)\n    }\n\n    emittedMutation.attributes[mutation.attributeName!] = transformedValue\n  }\n\n  return attributeMutations\n}\n\nexport function sortAddedAndMovedNodes(nodes: Node[]) {\n  nodes.sort((a, b) => {\n    const position = a.compareDocumentPosition(b)\n    /* eslint-disable no-bitwise */\n    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1\n    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return -1\n    }\n    /* eslint-enable no-bitwise */\n    return 0\n  })\n}\n\nfunction traverseRemovedShadowDom(removedNode: Node, shadowDomRemovedCallback: RemoveShadowRootCallBack) {\n  if (isNodeShadowHost(removedNode)) {\n    shadowDomRemovedCallback(removedNode.shadowRoot)\n  }\n  forEachChildNodes(removedNode, (childNode) => traverseRemovedShadowDom(childNode, shadowDomRemovedCallback))\n}\n\nexport function idsAreAssignedForNodeAndAncestors(node: Node, nodeIds: NodeIds): node is NodeWithSerializedNode {\n  let current: Node | null = node\n  while (current) {\n    if (nodeIds.get(current) === undefined && !isNodeShadowRoot(current)) {\n      return false\n    }\n    current = getParentNode(current)\n  }\n  return true\n}\n", "import type { RecordingScope } from './recordingScope.ts'\nimport type { EmitRecordCallback, EmitStatsCallback } from './record.types'\nimport { trackInput, trackMutation, trackScroll } from './trackers'\n\ninterface ShadowRootController {\n  stop: () => void\n  flush: () => void\n}\n\nexport type AddShadowRootCallBack = (shadowRoot: ShadowRoot, scope: RecordingScope) => void\nexport type RemoveShadowRootCallBack = (shadowRoot: ShadowRoot) => void\n\nexport interface ShadowRootsController {\n  addShadowRoot: AddShadowRootCallBack\n  removeShadowRoot: RemoveShadowRootCallBack\n  stop: () => void\n  flush: () => void\n}\n\nexport const initShadowRootsController = (\n  emitRecord: EmitRecordCallback,\n  emitStats: EmitStatsCallback\n): ShadowRootsController => {\n  const controllerByShadowRoot = new Map<ShadowRoot, ShadowRootController>()\n\n  const shadowRootsController: ShadowRootsController = {\n    addShadowRoot: (shadowRoot: ShadowRoot, scope: RecordingScope) => {\n      if (controllerByShadowRoot.has(shadowRoot)) {\n        return\n      }\n      const mutationTracker = trackMutation(shadowRoot, emitRecord, emitStats, scope)\n      // The change event does not bubble up across the shadow root, we have to listen on the shadow root\n      const inputTracker = trackInput(shadowRoot, emitRecord, scope)\n      // The scroll event does not bubble up across the shadow root, we have to listen on the shadow root\n      const scrollTracker = trackScroll(shadowRoot, emitRecord, scope)\n      controllerByShadowRoot.set(shadowRoot, {\n        flush: () => mutationTracker.flush(),\n        stop: () => {\n          mutationTracker.stop()\n          inputTracker.stop()\n          scrollTracker.stop()\n        },\n      })\n    },\n    removeShadowRoot: (shadowRoot: ShadowRoot) => {\n      const entry = controllerByShadowRoot.get(shadowRoot)\n      if (!entry) {\n        // unidentified root cause: observed in some cases with shadow DOM added by browser extensions\n        return\n      }\n      entry.stop()\n      controllerByShadowRoot.delete(shadowRoot)\n    },\n    stop: () => {\n      controllerByShadowRoot.forEach(({ stop }) => stop())\n    },\n    flush: () => {\n      controllerByShadowRoot.forEach(({ flush }) => flush())\n    },\n  }\n  return shadowRootsController\n}\n", "import { sendToExtension } from '@datadog/browser-core'\nimport type { LifeCycle, RumConfiguration, ViewHistory } from '@datadog/browser-rum-core'\nimport * as replayStats from '../replayStats'\nimport type { BrowserRecord } from '../../types'\nimport type { Tracker } from './trackers'\nimport {\n  trackFocus,\n  trackFrustration,\n  trackInput,\n  trackMediaInteraction,\n  trackMouseInteraction,\n  trackMove,\n  trackMutation,\n  trackScroll,\n  trackStyleSheet,\n  trackViewEnd,\n  trackViewportResize,\n  trackVisualViewportResize,\n} from './trackers'\nimport { createElementsScrollPositions } from './elementsScrollPositions'\nimport type { ShadowRootsController } from './shadowRootsController'\nimport { initShadowRootsController } from './shadowRootsController'\nimport { startFullSnapshots } from './startFullSnapshots'\nimport type { EmitRecordCallback, EmitStatsCallback } from './record.types'\nimport { createRecordingScope } from './recordingScope'\n\nexport interface RecordOptions {\n  emitRecord: EmitRecordCallback\n  emitStats: EmitStatsCallback\n  configuration: RumConfiguration\n  lifeCycle: LifeCycle\n  viewHistory: ViewHistory\n}\n\nexport interface RecordAPI {\n  stop: () => void\n  flushMutations: () => void\n  shadowRootsController: ShadowRootsController\n}\n\nexport function record(options: RecordOptions): RecordAPI {\n  const { emitRecord, emitStats, configuration, lifeCycle } = options\n  // runtime checks for user options\n  if (!emitRecord || !emitStats) {\n    throw new Error('emit functions are required')\n  }\n\n  const processRecord: EmitRecordCallback = (record: BrowserRecord) => {\n    emitRecord(record)\n    sendToExtension('record', { record })\n    const view = options.viewHistory.findView()!\n    replayStats.addRecord(view.id)\n  }\n\n  const shadowRootsController = initShadowRootsController(processRecord, emitStats)\n  const scope = createRecordingScope(configuration, createElementsScrollPositions(), shadowRootsController)\n\n  const { stop: stopFullSnapshots } = startFullSnapshots(lifeCycle, processRecord, emitStats, flushMutations, scope)\n\n  function flushMutations() {\n    shadowRootsController.flush()\n    mutationTracker.flush()\n  }\n\n  const mutationTracker = trackMutation(document, processRecord, emitStats, scope)\n  const trackers: Tracker[] = [\n    mutationTracker,\n    trackMove(processRecord, scope),\n    trackMouseInteraction(processRecord, scope),\n    trackScroll(document, processRecord, scope),\n    trackViewportResize(processRecord, scope),\n    trackInput(document, processRecord, scope),\n    trackMediaInteraction(processRecord, scope),\n    trackStyleSheet(processRecord, scope),\n    trackFocus(processRecord, scope),\n    trackVisualViewportResize(processRecord, scope),\n    trackFrustration(lifeCycle, processRecord, scope),\n    trackViewEnd(lifeCycle, processRecord, flushMutations),\n  ]\n\n  return {\n    stop: () => {\n      shadowRootsController.stop()\n      trackers.forEach((tracker) => tracker.stop())\n      stopFullSnapshots()\n    },\n    flushMutations,\n    shadowRootsController,\n  }\n}\n", "import type { Payload, Uint8ArrayBuffer } from '@datadog/browser-core'\nimport type { BrowserSegmentMetadata } from '../../types'\nimport type { SerializationMetric, SerializationStats } from '../record'\n\nexport type BrowserSegmentMetadataAndSegmentSizes = BrowserSegmentMetadata & {\n  raw_segment_size: number\n  compressed_segment_size: number\n}\n\nexport type ReplayPayload = Payload & {\n  cssText: SerializationMetric\n  isFullSnapshot: boolean\n  rawSize: number\n  recordCount: number\n  serializationDuration: SerializationMetric\n}\n\nexport function buildReplayPayload(\n  data: Uint8ArrayBuffer,\n  metadata: BrowserSegmentMetadata,\n  stats: SerializationStats,\n  rawSegmentBytesCount: number\n): ReplayPayload {\n  const formData = new FormData()\n\n  formData.append(\n    'segment',\n    new Blob([data], {\n      type: 'application/octet-stream',\n    }),\n    `${metadata.session.id}-${metadata.start}`\n  )\n\n  const metadataAndSegmentSizes: BrowserSegmentMetadataAndSegmentSizes = {\n    raw_segment_size: rawSegmentBytesCount,\n    compressed_segment_size: data.byteLength,\n    ...metadata,\n  }\n\n  const serializedMetadataAndSegmentSizes = JSON.stringify(metadataAndSegmentSizes)\n  formData.append('event', new Blob([serializedMetadataAndSegmentSizes], { type: 'application/json' }))\n\n  return {\n    data: formData,\n    bytesCount: data.byteLength,\n    cssText: stats.cssText,\n    isFullSnapshot: metadata.index_in_view === 0,\n    rawSize: rawSegmentBytesCount,\n    recordCount: metadata.records_count,\n    serializationDuration: stats.serializationDuration,\n  }\n}\n", "import type { Encoder, EncoderResult, Uint8ArrayBuffer } from '@datadog/browser-core'\nimport type { BrowserRecord, BrowserSegmentMetadata, CreationReason, SegmentContext } from '../../types'\nimport { RecordType } from '../../types'\nimport * as replayStats from '../replayStats'\nimport type { SerializationStats } from '../record'\nimport { aggregateSerializationStats, createSerializationStats } from '../record'\n\nexport type FlushReason = Exclude<CreationReason, 'init'> | 'stop'\nexport type FlushCallback = (\n  metadata: BrowserSegmentMetadata,\n  stats: SerializationStats,\n  encoderResult: EncoderResult<Uint8ArrayBuffer>\n) => void\nexport type AddRecordCallback = (encodedBytesCount: number) => void\n\nexport interface Segment {\n  addRecord: (record: BrowserRecord, callback: AddRecordCallback) => void\n  addStats: (stats: SerializationStats) => void\n  flush: (callback: FlushCallback) => void\n}\n\nexport function createSegment({\n  context,\n  creationReason,\n  encoder,\n}: {\n  context: SegmentContext\n  creationReason: CreationReason\n  encoder: Encoder<Uint8ArrayBuffer>\n}): Segment {\n  let encodedBytesCount = 0\n  const viewId = context.view.id\n  const indexInView = replayStats.getSegmentsCount(viewId)\n  const metadata: BrowserSegmentMetadata = {\n    start: Infinity,\n    end: -Infinity,\n    creation_reason: creationReason,\n    records_count: 0,\n    has_full_snapshot: false,\n    index_in_view: indexInView,\n    source: 'browser' as const,\n    ...context,\n  }\n\n  const serializationStats = createSerializationStats()\n  replayStats.addSegment(viewId)\n\n  function addRecord(record: BrowserRecord, callback: AddRecordCallback): void {\n    metadata.start = Math.min(metadata.start, record.timestamp)\n    metadata.end = Math.max(metadata.end, record.timestamp)\n    metadata.records_count += 1\n    metadata.has_full_snapshot ||= record.type === RecordType.FullSnapshot\n\n    const prefix = encoder.isEmpty ? '{\"records\":[' : ','\n    encoder.write(prefix + JSON.stringify(record), (additionalEncodedBytesCount) => {\n      encodedBytesCount += additionalEncodedBytesCount\n      callback(encodedBytesCount)\n    })\n  }\n\n  function addStats(stats: SerializationStats): void {\n    aggregateSerializationStats(serializationStats, stats)\n  }\n\n  function flush(callback: FlushCallback) {\n    if (encoder.isEmpty) {\n      throw new Error('Empty segment flushed')\n    }\n\n    encoder.write(`],${JSON.stringify(metadata).slice(1)}\\n`)\n    encoder.finish((encoderResult) => {\n      replayStats.addWroteData(metadata.view.id, encoderResult.rawBytesCount)\n      callback(metadata, serializationStats, encoderResult)\n    })\n  }\n\n  return { addRecord, addStats, flush }\n}\n", "import type { DeflateEncoder, HttpRequest, TimeoutId } from '@datadog/browser-core'\nimport { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core'\nimport type { LifeCycle, ViewHistory, RumSessionManager, RumConfiguration } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { BrowserRecord, CreationReason, SegmentContext } from '../../types'\nimport type { SerializationStats } from '../record'\nimport type { ReplayPayload } from './buildReplayPayload'\nimport { buildReplayPayload } from './buildReplayPayload'\nimport type { FlushReason, Segment } from './segment'\nimport { createSegment } from './segment'\n\nexport const SEGMENT_DURATION_LIMIT = 5 * ONE_SECOND\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport let SEGMENT_BYTES_LIMIT = 60_000\n\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\n\ninterface SegmentCollector {\n  addRecord(this: void, record: BrowserRecord): void\n  addStats(this: void, stats: SerializationStats): void\n  stop(this: void): void\n}\n\nexport function startSegmentCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewHistory: ViewHistory,\n  httpRequest: HttpRequest<ReplayPayload>,\n  encoder: DeflateEncoder\n): SegmentCollector {\n  return doStartSegmentCollection(\n    lifeCycle,\n    () => computeSegmentContext(configuration.applicationId, sessionManager, viewHistory),\n    httpRequest,\n    encoder\n  )\n}\n\nconst enum SegmentCollectionStatus {\n  WaitingForInitialRecord,\n  SegmentPending,\n  Stopped,\n}\ntype SegmentCollectionState =\n  | {\n      status: SegmentCollectionStatus.WaitingForInitialRecord\n      nextSegmentCreationReason: CreationReason\n    }\n  | {\n      status: SegmentCollectionStatus.SegmentPending\n      segment: Segment\n      expirationTimeoutId: TimeoutId\n    }\n  | {\n      status: SegmentCollectionStatus.Stopped\n    }\n\nexport function doStartSegmentCollection(\n  lifeCycle: LifeCycle,\n  getSegmentContext: () => SegmentContext | undefined,\n  httpRequest: HttpRequest<ReplayPayload>,\n  encoder: DeflateEncoder\n): SegmentCollector {\n  let state: SegmentCollectionState = {\n    status: SegmentCollectionStatus.WaitingForInitialRecord,\n    nextSegmentCreationReason: 'init',\n  }\n\n  const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, () => {\n    flushSegment('view_change')\n  })\n\n  const { unsubscribe: unsubscribePageMayExit } = lifeCycle.subscribe(\n    LifeCycleEventType.PAGE_MAY_EXIT,\n    (pageMayExitEvent) => {\n      flushSegment(pageMayExitEvent.reason as FlushReason)\n    }\n  )\n\n  function flushSegment(flushReason: FlushReason) {\n    if (state.status === SegmentCollectionStatus.SegmentPending) {\n      state.segment.flush((metadata, stats, encoderResult) => {\n        const payload = buildReplayPayload(encoderResult.output, metadata, stats, encoderResult.rawBytesCount)\n\n        if (isPageExitReason(flushReason)) {\n          httpRequest.sendOnExit(payload)\n        } else {\n          httpRequest.send(payload)\n        }\n      })\n      clearTimeout(state.expirationTimeoutId)\n    }\n\n    if (flushReason !== 'stop') {\n      state = {\n        status: SegmentCollectionStatus.WaitingForInitialRecord,\n        nextSegmentCreationReason: flushReason,\n      }\n    } else {\n      state = {\n        status: SegmentCollectionStatus.Stopped,\n      }\n    }\n  }\n\n  return {\n    addRecord: (record: BrowserRecord) => {\n      if (state.status === SegmentCollectionStatus.Stopped) {\n        return\n      }\n\n      if (state.status === SegmentCollectionStatus.WaitingForInitialRecord) {\n        const context = getSegmentContext()\n        if (!context) {\n          return\n        }\n\n        state = {\n          status: SegmentCollectionStatus.SegmentPending,\n          segment: createSegment({ encoder, context, creationReason: state.nextSegmentCreationReason }),\n          expirationTimeoutId: setTimeout(() => {\n            flushSegment('segment_duration_limit')\n          }, SEGMENT_DURATION_LIMIT),\n        }\n      }\n\n      state.segment.addRecord(record, (encodedBytesCount) => {\n        if (encodedBytesCount > SEGMENT_BYTES_LIMIT) {\n          flushSegment('segment_bytes_limit')\n        }\n      })\n    },\n\n    addStats: (stats: SerializationStats) => {\n      if (state.status === SegmentCollectionStatus.SegmentPending) {\n        state.segment.addStats(stats)\n      }\n    },\n\n    stop: () => {\n      flushSegment('stop')\n      unsubscribeViewCreated()\n      unsubscribePageMayExit()\n    },\n  }\n}\n\nexport function computeSegmentContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewHistory: ViewHistory\n) {\n  const session = sessionManager.findTrackedSession()\n  const viewContext = viewHistory.findView()\n  if (!session || !viewContext) {\n    return undefined\n  }\n  return {\n    application: {\n      id: applicationId,\n    },\n    session: {\n      id: session.id,\n    },\n    view: {\n      id: viewContext.id,\n    },\n  }\n}\n\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60_000) {\n  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit\n}\n", "import type { BandwidthStats, Context, HttpRequestEvent, Observable, Telemetry } from '@datadog/browser-core'\nimport { TelemetryMetrics, addTelemetryMetrics, noop } from '@datadog/browser-core'\nimport type { ReplayPayload } from './buildReplayPayload'\n\ninterface SegmentMetrics extends Context {\n  cssText: {\n    count: number\n    max: number\n    sum: number\n  }\n  isFullSnapshot: boolean\n  ongoingRequests: {\n    count: number\n    totalSize: number\n  }\n  recordCount: number\n  result: 'failure' | 'queue-full' | 'success'\n  serializationDuration: {\n    count: number\n    max: number\n    sum: number\n  }\n  size: {\n    compressed: number\n    raw: number\n  }\n}\n\nexport function startSegmentTelemetry(\n  telemetry: Telemetry,\n  requestObservable: Observable<HttpRequestEvent<ReplayPayload>>\n) {\n  if (!telemetry.metricsEnabled) {\n    return { stop: noop }\n  }\n\n  const { unsubscribe } = requestObservable.subscribe((requestEvent) => {\n    if (\n      requestEvent.type === 'failure' ||\n      requestEvent.type === 'queue-full' ||\n      (requestEvent.type === 'success' && requestEvent.payload.isFullSnapshot)\n    ) {\n      const metrics = createSegmentMetrics(requestEvent.type, requestEvent.bandwidth, requestEvent.payload)\n      // monitor-until: 2026-07-01\n      addTelemetryMetrics(TelemetryMetrics.SEGMENT_METRICS_TELEMETRY_NAME, { metrics })\n    }\n  })\n\n  return {\n    stop: unsubscribe,\n  }\n}\n\nfunction createSegmentMetrics(\n  result: SegmentMetrics['result'],\n  bandwidthStats: BandwidthStats,\n  payload: ReplayPayload\n): SegmentMetrics {\n  return {\n    cssText: {\n      count: payload.cssText.count,\n      max: payload.cssText.max,\n      sum: payload.cssText.sum,\n    },\n    isFullSnapshot: payload.isFullSnapshot,\n    ongoingRequests: {\n      count: bandwidthStats.ongoingRequestCount,\n      totalSize: bandwidthStats.ongoingByteCount,\n    },\n    recordCount: payload.recordCount,\n    result,\n    serializationDuration: {\n      count: payload.serializationDuration.count,\n      max: payload.serializationDuration.max,\n      sum: payload.serializationDuration.sum,\n    },\n    size: {\n      compressed: payload.bytesCount,\n      raw: payload.rawSize,\n    },\n  }\n}\n", "import { getEventBridge } from '@datadog/browser-core'\nimport type { ViewHistory } from '@datadog/browser-rum-core'\nimport type { BrowserRecord } from '../types'\n\nexport function startRecordBridge(viewHistory: ViewHistory) {\n  const bridge = getEventBridge<'record', BrowserRecord>()!\n\n  return {\n    addRecord: (record: BrowserRecord) => {\n      // Get the current active view, not at the time of the record, aligning with the segment logic.\n      // This approach could potentially associate the record to an incorrect view, in case the record date is in the past (e.g. frustration records).\n      // However the risk is minimal. We could address the issue when potential negative impact are identified.\n      const view = viewHistory.findView()!\n      bridge.send('record', record, view.id)\n    },\n  }\n}\n", "import type { RawError, HttpRequest, DeflateEncoder, Telemetry } from '@datadog/browser-core'\nimport { createHttpRequest, addTelemetryDebug, canUseEventBridge, noop } from '@datadog/browser-core'\nimport type { LifeCycle, ViewHistory, RumConfiguration, RumSessionManager } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\n\nimport type { SerializationStats } from '../domain/record'\nimport { record } from '../domain/record'\nimport type { ReplayPayload } from '../domain/segmentCollection'\nimport { startSegmentCollection, SEGMENT_BYTES_LIMIT, startSegmentTelemetry } from '../domain/segmentCollection'\nimport type { BrowserRecord } from '../types'\nimport { startRecordBridge } from '../domain/startRecordBridge'\n\nexport function startRecording(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewHistory: ViewHistory,\n  encoder: DeflateEncoder,\n  telemetry: Telemetry,\n  httpRequest?: HttpRequest<ReplayPayload>\n) {\n  const cleanupTasks: Array<() => void> = []\n\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error })\n    // monitor-until: forever, to keep an eye on the errors reported to customers\n    addTelemetryDebug('Error reported to customer', { 'error.message': error.message })\n  }\n\n  const replayRequest =\n    httpRequest || createHttpRequest([configuration.sessionReplayEndpointBuilder], reportError, SEGMENT_BYTES_LIMIT)\n\n  let addRecord: (record: BrowserRecord) => void\n  let addStats: (stats: SerializationStats) => void\n\n  if (!canUseEventBridge()) {\n    const segmentCollection = startSegmentCollection(\n      lifeCycle,\n      configuration,\n      sessionManager,\n      viewHistory,\n      replayRequest,\n      encoder\n    )\n    addRecord = segmentCollection.addRecord\n    addStats = segmentCollection.addStats\n    cleanupTasks.push(segmentCollection.stop)\n\n    const segmentTelemetry = startSegmentTelemetry(telemetry, replayRequest.observable)\n    cleanupTasks.push(segmentTelemetry.stop)\n  } else {\n    ;({ addRecord } = startRecordBridge(viewHistory))\n    addStats = noop\n  }\n\n  const { stop: stopRecording } = record({\n    emitRecord: addRecord,\n    emitStats: addStats,\n    configuration,\n    lifeCycle,\n    viewHistory,\n  })\n  cleanupTasks.push(stopRecording)\n\n  return {\n    stop: () => {\n      cleanupTasks.forEach((task) => task())\n    },\n  }\n}\n"],
  "mappings": "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",
  "names": ["document", "document", "record", "target", "rules", "index", "target", "record", "addRecord", "record", "record", "record", "addRecord"]
}
