{
  "version": 3,
  "sources": ["../../@datadog/browser-rum/src/domain/profiling/utils/getNumberOfSamples.ts", "../../@datadog/browser-rum/src/domain/profiling/utils/getDefaultViewName.ts", "../../@datadog/browser-rum/src/domain/profiling/utils/getCustomOrDefaultViewName.ts", "../../@datadog/browser-rum/src/domain/profiling/transport/buildProfileEventAttributes.ts", "../../@datadog/browser-rum/src/domain/profiling/transport/assembly.ts", "../../@datadog/browser-rum/src/domain/profiling/profiler.ts"],
  "sourcesContent": ["import type { ProfilerSample } from '../types'\n\n/**\n * Counts number of samples when the thread was not idle (stackId is defined)\n *\n * @param samples - Array of collected samples\n * @returns Number of samples\n */\nexport function getNumberOfSamples(samples: ProfilerSample[]): number {\n  let numberOfSamples = 0\n  for (const sample of samples) {\n    if (sample.stackId !== undefined) {\n      numberOfSamples++\n    }\n  }\n  return numberOfSamples\n}\n", "// This is the regex used to extract the path from the url (from SimpleUrlGroupingProcessor.java)\n// It's a bit different from the one in the java code because we removed the lookbehind unsupported by Safari.\nconst PATH_MIXED_ALPHANUMERICS = /\\/(?![vV]\\d{1,2}\\/)([^/\\d?]*\\d+[^/?]*)/g\n\nexport function getDefaultViewName(viewPathUrl: string): string {\n  if (!viewPathUrl) {\n    return '/'\n  }\n\n  // Replace all the mixed alphanumerics with a ?\n  return viewPathUrl.replace(PATH_MIXED_ALPHANUMERICS, '/?')\n}\n", "import { getDefaultViewName } from './getDefaultViewName'\n\nexport const getCustomOrDefaultViewName = (customViewName: string | undefined, viewPathUrl: string): string =>\n  customViewName || getDefaultViewName(viewPathUrl)\n", "import type { RumProfilerTrace, RumViewEntry } from '../types'\n\nexport interface ProfileEventAttributes {\n  application: { id: string }\n  session?: { id: string }\n  view?: { id: string[]; name: string[] }\n  long_task?: { id: string[] }\n}\n\n/**\n * Builds attributes for the Profile Event.\n *\n * @param profilerTrace - Profiler trace\n * @param applicationId - application id.\n * @param sessionId - session id.\n * @returns Additional attributes.\n */\nexport function buildProfileEventAttributes(\n  profilerTrace: RumProfilerTrace,\n  applicationId: string,\n  sessionId: string | undefined\n): ProfileEventAttributes {\n  const attributes: ProfileEventAttributes = {\n    application: {\n      id: applicationId,\n    },\n  }\n  if (sessionId) {\n    attributes.session = {\n      id: sessionId,\n    }\n  }\n\n  // Extract view ids and names from the profiler trace and add them as attributes of the profile event.\n  // This will be used to filter the profiles by @view.id and/or @view.name.\n  const { ids, names } = extractViewIdsAndNames(profilerTrace.views)\n\n  if (ids.length) {\n    attributes.view = {\n      id: ids,\n      name: names,\n    }\n  }\n  const longTaskIds: string[] = profilerTrace.longTasks.map((longTask) => longTask.id).filter((id) => id !== undefined)\n\n  if (longTaskIds.length) {\n    attributes.long_task = { id: longTaskIds }\n  }\n  return attributes\n}\n\nfunction extractViewIdsAndNames(views: RumViewEntry[]): { ids: string[]; names: string[] } {\n  const result: { ids: string[]; names: string[] } = { ids: [], names: [] }\n  for (const view of views) {\n    result.ids.push(view.viewId)\n\n    if (view.viewName) {\n      result.names.push(view.viewName)\n    }\n  }\n\n  // Remove duplicates\n  result.names = Array.from(new Set(result.names))\n\n  return result\n}\n", "import { buildTags, currentDrift } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { RumProfilerTrace } from '../types'\nimport { buildProfileEventAttributes } from './buildProfileEventAttributes'\nimport type { ProfileEventAttributes } from './buildProfileEventAttributes'\n\nexport interface ProfileEvent extends ProfileEventAttributes {\n  attachments: string[]\n  start: string // ISO date\n  end: string // ISO date\n  family: 'chrome'\n  runtime: 'chrome'\n  format: 'json'\n  version: 4\n  tags_profiler: string\n  _dd: {\n    clock_drift: number\n  }\n}\n\nexport interface ProfileEventPayload {\n  event: ProfileEvent\n  'wall-time.json': RumProfilerTrace\n}\n\nexport function assembleProfilingPayload(\n  profilerTrace: RumProfilerTrace,\n  configuration: RumConfiguration,\n  sessionId: string | undefined\n): ProfileEventPayload {\n  const event = buildProfileEvent(profilerTrace, configuration, sessionId)\n\n  return {\n    event,\n    'wall-time.json': profilerTrace,\n  }\n}\n\nfunction buildProfileEvent(\n  profilerTrace: RumProfilerTrace,\n  configuration: RumConfiguration,\n  sessionId: string | undefined\n): ProfileEvent {\n  const tags = buildTags(configuration) // TODO: get that from the tagContext hook\n  const profileAttributes = buildProfileEventAttributes(profilerTrace, configuration.applicationId, sessionId)\n  const profileEventTags = buildProfileEventTags(tags)\n\n  const profileEvent: ProfileEvent = {\n    ...profileAttributes,\n    attachments: ['wall-time.json'],\n    start: new Date(profilerTrace.startClocks.timeStamp).toISOString(),\n    end: new Date(profilerTrace.endClocks.timeStamp).toISOString(),\n    family: 'chrome',\n    runtime: 'chrome',\n    format: 'json',\n    version: 4, // Ingestion event version (not the version application tag)\n    tags_profiler: profileEventTags.join(','),\n    _dd: {\n      clock_drift: currentDrift(),\n    },\n  }\n\n  return profileEvent\n}\n\n/**\n * Builds tags for the Profile Event.\n *\n * @param tags - RUM tags\n * @returns Combined tags for the Profile Event.\n */\nfunction buildProfileEventTags(tags: string[]): string[] {\n  // Tags already contains the common tags for all events. (service, env, version, etc.)\n  // Here we are adding some specific-to-profiling tags.\n  const profileEventTags = tags.concat(['language:javascript', 'runtime:chrome', 'family:chrome', 'host:browser'])\n\n  return profileEventTags\n}\n", "import type { Encoder } from '@datadog/browser-core'\nimport {\n  addEventListener,\n  clearTimeout,\n  setTimeout,\n  DOM_EVENT,\n  monitorError,\n  display,\n  getGlobalObject,\n  clocksOrigin,\n  clocksNow,\n  elapsed,\n  DeflateEncoderStreamId,\n} from '@datadog/browser-core'\n\nimport type {\n  LifeCycle,\n  LongTaskContexts,\n  RumConfiguration,\n  RumSessionManager,\n  TransportPayload,\n  ViewHistory,\n} from '@datadog/browser-rum-core'\nimport { createFormDataTransport, LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type {\n  RumProfilerTrace,\n  RumProfilerInstance,\n  Profiler,\n  RUMProfiler,\n  RUMProfilerConfiguration,\n  RumProfilerStoppedInstance,\n  RumViewEntry,\n} from './types'\nimport { getNumberOfSamples } from './utils/getNumberOfSamples'\nimport type { ProfilingContextManager } from './profilingContext'\nimport { getCustomOrDefaultViewName } from './utils/getCustomOrDefaultViewName'\nimport { assembleProfilingPayload } from './transport/assembly'\n\nexport const DEFAULT_RUM_PROFILER_CONFIGURATION: RUMProfilerConfiguration = {\n  sampleIntervalMs: 10, // Sample stack trace every 10ms\n  collectIntervalMs: 60000, // Collect data every minute\n  minProfileDurationMs: 5000, // Require at least 5 seconds of profile data to reduce noise and cost\n  minNumberOfSamples: 50, // Require at least 50 samples (~500 ms) to report a profile to reduce noise and cost\n}\n\nexport function createRumProfiler(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  session: RumSessionManager,\n  profilingContextManager: ProfilingContextManager,\n  longTaskContexts: LongTaskContexts,\n  createEncoder: (streamId: DeflateEncoderStreamId) => Encoder,\n  viewHistory: ViewHistory,\n  profilerConfiguration: RUMProfilerConfiguration = DEFAULT_RUM_PROFILER_CONFIGURATION\n): RUMProfiler {\n  const transport = createFormDataTransport(configuration, lifeCycle, createEncoder, DeflateEncoderStreamId.PROFILING)\n\n  let lastViewEntry: RumViewEntry | undefined\n\n  // Global clean-up tasks for listeners that are not specific to a profiler instance (eg. visibility change, before unload)\n  const globalCleanupTasks: Array<() => void> = []\n\n  let instance: RumProfilerInstance = { state: 'stopped', stateReason: 'initializing' }\n\n  // Stops the profiler when session expires\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_EXPIRED, () => {\n    stopProfiling('session-expired').catch(monitorError)\n  })\n\n  // Start the profiler again when session is renewed\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    if (instance.state === 'stopped' && instance.stateReason === 'session-expired') {\n      start() // Only restart the profiler if it was stopped due to session expiration. Avoid restarting the profiler if it was stopped manually by the user.\n    }\n  })\n\n  // Public API to start the profiler.\n  function start(): void {\n    if (instance.state === 'running') {\n      return\n    }\n\n    const viewEntry = viewHistory.findView()\n\n    // Add initial view\n    // Note: `viewEntry.name` is only filled when users use manual view creation via `startView` method.\n    lastViewEntry = viewEntry\n      ? {\n          startClocks: viewEntry.startClocks,\n          viewId: viewEntry.id,\n          viewName: getCustomOrDefaultViewName(viewEntry.name, document.location.pathname),\n        }\n      : undefined\n\n    // Add global clean-up tasks for listeners that are not specific to a profiler instance (eg. visibility change, before unload)\n    globalCleanupTasks.push(\n      addEventListener(configuration, window, DOM_EVENT.VISIBILITY_CHANGE, handleVisibilityChange).stop,\n      addEventListener(configuration, window, DOM_EVENT.BEFORE_UNLOAD, handleBeforeUnload).stop\n    )\n\n    // Start profiler instance\n    startNextProfilerInstance()\n  }\n\n  // Public API to manually stop the profiler.\n  async function stop() {\n    await stopProfiling('stopped-by-user')\n  }\n\n  async function stopProfiling(reason: RumProfilerStoppedInstance['stateReason']) {\n    // Stop current profiler instance\n    await stopProfilerInstance(reason)\n\n    // Cleanup global listeners\n    globalCleanupTasks.forEach((task) => task())\n\n    // Update Profiling status once the Profiler has been stopped.\n    profilingContextManager.set({ status: 'stopped', error_reason: undefined })\n  }\n\n  /**\n   * Whenever a new Profiler instance is started, we need to add event listeners to surroundings (RUM Events, Long Tasks, etc) to enrich the Profiler data.\n   * If the instance is already running, we can keep the same event listeners.\n   */\n  function addEventListeners(existingInstance: RumProfilerInstance) {\n    if (existingInstance.state === 'running') {\n      // Instance is already running, so we can keep same event listeners.\n      return {\n        cleanupTasks: existingInstance.cleanupTasks,\n      }\n    }\n\n    // Store clean-up tasks for this instance (tasks to be executed when the Profiler is stopped or paused.)\n    const cleanupTasks = []\n\n    // Whenever the View is updated, we add a views entry to the profiler instance.\n    const viewUpdatedSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, (view) => {\n      const viewEntry = {\n        viewId: view.id,\n        // Note: `viewName` is only filled when users use manual view creation via `startView` method.\n        viewName: getCustomOrDefaultViewName(view.name, document.location.pathname),\n        startClocks: view.startClocks,\n      }\n\n      collectViewEntry(viewEntry)\n\n      // Update last view entry\n      lastViewEntry = viewEntry\n    })\n    cleanupTasks.push(viewUpdatedSubscription.unsubscribe)\n\n    return {\n      cleanupTasks,\n    }\n  }\n\n  function startNextProfilerInstance(): void {\n    // These APIs might be unavailable in some browsers\n    const globalThisProfiler: Profiler | undefined = getGlobalObject<any>().Profiler\n\n    if (!globalThisProfiler) {\n      profilingContextManager.set({ status: 'error', error_reason: 'not-supported-by-browser' })\n      throw new Error('RUM Profiler is not supported in this browser.')\n    }\n\n    // Don't wait for data collection to start next instance\n    collectProfilerInstance(instance).catch(monitorError)\n\n    const { cleanupTasks } = addEventListeners(instance)\n\n    let profiler: Profiler\n    try {\n      // We have to create new Profiler each time we start a new instance\n      profiler = new globalThisProfiler({\n        sampleInterval: profilerConfiguration.sampleIntervalMs,\n        // Keep buffer size at 1.5 times of minimum required to collect data for a profiling instance\n        maxBufferSize: Math.round(\n          (profilerConfiguration.collectIntervalMs * 1.5) / profilerConfiguration.sampleIntervalMs\n        ),\n      })\n    } catch (e) {\n      if (e instanceof Error && e.message.includes('disabled by Document Policy')) {\n        // Missing Response Header (`js-profiling`) that is required to enable the profiler.\n        // We should suggest the user to enable the Response Header in their server configuration.\n        display.warn(\n          '[DD_RUM] Profiler startup failed. Ensure your server includes the `Document-Policy: js-profiling` response header when serving HTML pages.',\n          e\n        )\n        profilingContextManager.set({ status: 'error', error_reason: 'missing-document-policy-header' })\n      } else {\n        profilingContextManager.set({ status: 'error', error_reason: 'unexpected-exception' })\n      }\n      return\n    }\n\n    profilingContextManager.set({ status: 'running', error_reason: undefined })\n\n    // Kick-off the new instance\n    instance = {\n      state: 'running',\n      startClocks: clocksNow(),\n      profiler,\n      timeoutId: setTimeout(startNextProfilerInstance, profilerConfiguration.collectIntervalMs),\n      views: [],\n      cleanupTasks,\n      longTasks: [],\n    }\n\n    // Add last view entry\n    collectViewEntry(lastViewEntry)\n\n    // Add event handler case we overflow the buffer\n    profiler.addEventListener('samplebufferfull', handleSampleBufferFull)\n  }\n\n  async function collectProfilerInstance(lastInstance: RumProfilerInstance) {\n    if (lastInstance.state !== 'running') {\n      return\n    }\n\n    // Cleanup instance\n    clearTimeout(lastInstance.timeoutId)\n    lastInstance.profiler.removeEventListener('samplebufferfull', handleSampleBufferFull)\n\n    // Store instance data snapshot in local variables to use in async callback\n    const { startClocks, views } = lastInstance\n\n    // Stop current profiler to get trace\n    await lastInstance.profiler\n      .stop()\n      .then((trace) => {\n        const endClocks = clocksNow()\n        const duration = elapsed(startClocks.timeStamp, endClocks.timeStamp)\n        const longTasks = longTaskContexts.findLongTasks(startClocks.relative, duration)\n        const isBelowDurationThreshold = duration < profilerConfiguration.minProfileDurationMs\n        const isBelowSampleThreshold = getNumberOfSamples(trace.samples) < profilerConfiguration.minNumberOfSamples\n\n        if (longTasks.length === 0 && (isBelowDurationThreshold || isBelowSampleThreshold)) {\n          // Skip very short profiles to reduce noise and cost, but keep them if they contain long tasks.\n          return\n        }\n\n        handleProfilerTrace(\n          // Enrich trace with time and instance data\n          Object.assign(trace, {\n            startClocks,\n            endClocks,\n            clocksOrigin: clocksOrigin(),\n            longTasks,\n            views,\n            sampleInterval: profilerConfiguration.sampleIntervalMs,\n          })\n        )\n      })\n      .catch(monitorError)\n  }\n\n  async function stopProfilerInstance(stateReason: RumProfilerStoppedInstance['stateReason']) {\n    if (instance.state !== 'running') {\n      return\n    }\n    await onPauseOrStopProfilerInstance()\n    instance = { state: 'stopped', stateReason }\n  }\n\n  async function pauseProfilerInstance() {\n    if (instance.state !== 'running') {\n      return\n    }\n    await onPauseOrStopProfilerInstance()\n    instance = { state: 'paused' }\n  }\n\n  async function onPauseOrStopProfilerInstance() {\n    if (instance.state !== 'running') {\n      return\n    }\n    // Cleanup tasks\n    instance.cleanupTasks.forEach((cleanupTask) => cleanupTask())\n\n    await collectProfilerInstance(instance)\n  }\n\n  function collectViewEntry(viewEntry: RumViewEntry | undefined): void {\n    if (instance.state !== 'running' || !viewEntry) {\n      return\n    }\n\n    // Add entry to views\n    instance.views.push(viewEntry)\n  }\n\n  function handleProfilerTrace(trace: RumProfilerTrace): void {\n    // Find current session to assign it to the Profile.\n    const sessionId = session.findTrackedSession()?.id\n    const payload = assembleProfilingPayload(trace, configuration, sessionId)\n\n    void transport.send(payload as unknown as TransportPayload)\n  }\n\n  function handleSampleBufferFull(): void {\n    startNextProfilerInstance()\n  }\n\n  function handleVisibilityChange(): void {\n    if (document.visibilityState === 'hidden' && instance.state === 'running') {\n      // Pause when tab is hidden. We use paused state to distinguish between\n      // paused by visibility change and stopped by user.\n      // If profiler is paused by the visibility change, we should resume when\n      // tab becomes visible again. That's not the case when user stops the profiler.\n      pauseProfilerInstance().catch(monitorError)\n    } else if (document.visibilityState === 'visible' && instance.state === 'paused') {\n      // Resume when tab becomes visible again\n      startNextProfilerInstance()\n    }\n  }\n\n  function handleBeforeUnload(): void {\n    // `unload` can in some cases be triggered while the page is still active (link to a different protocol like mailto:).\n    // We can immediately flush (by starting a new profiler instance) to make sure we receive the data, and at the same time keep the profiler active.\n    // In case of the regular unload, the profiler will be shut down anyway.\n    startNextProfilerInstance()\n  }\n\n  function isStopped() {\n    return instance.state === 'stopped'\n  }\n\n  function isRunning() {\n    return instance.state === 'running'\n  }\n\n  function isPaused() {\n    return instance.state === 'paused'\n  }\n\n  return { start, stop, isStopped, isRunning, isPaused }\n}\n"],
  "mappings": "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",
  "names": []
}
